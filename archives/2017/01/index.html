
<!DOCTYPE html>
<html lang="ko">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Owen&#39;s Blog">
    <title>Archives: 2017/1 - Owen&#39;s Blog</title>
    <meta name="author" content="Owen">
    
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <meta property="og:type" content="blog">
<meta property="og:title" content="Owen's Blog">
<meta property="og:url" content="http://wooner.net/archives/2017/01/index.html">
<meta property="og:site_name" content="Owen's Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Owen's Blog">
    
    
        
    
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/font-awesome.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox-thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">Owen&#39;s Blog</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/atom.xml"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/01/27/angular-detection/">
                            Angular2의 변화 탐지(Change Detection)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-01-27T22:34:00+09:00">
	
		    1월 27, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Angular/">Angular</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p><strong>이 글은 <a href="https://blog.thoughtram.io/angular/2016/02/22/angular-2-change-detection-explained.html" target="_blank" rel="external">Thoughtram 블로그</a>의 글을 번역한 것입니다. 번역이 미흡하더라도 너그럽게 이해해주세요.</strong></p>
<p>만일 이 이야기에 흥미가 있다면, 이 <a href="https://pascalprecht.github.io/slides/angular-2-change-detection-explained/#/" target="_blank" rel="external">슬라이드</a>를 보거나 <a href="https://www.youtube.com/watch?v=CUxD91DWkGM" target="_blank" rel="external">유튜브 비디오</a>를 봐도 됩니다.</p>
<h3 id="What’s-Change-Detection-anyways"><a href="#What’s-Change-Detection-anyways" class="headerlink" title="What’s Change Detection anyways?"></a>What’s Change Detection anyways?</h3><p>변화 감지(change detection)의 기본적인 태스크는 프로그램 내부의 상태(stats)를 가져와서 그것을 사용자 인터페이스에 구현하는 것입니다. 이 상태는 objects, arrays, primitives등 모든 종류의 자바스크립트 데이터 구조일 것입니다.</p>
<p>이 stats는 사용자 인터페이스나 DOM 웹사이트의 특정부분의 paragraphs, forms, 링크 또는 버튼 에서 보여질 것입니다. 따라서 기본적으로 우리는 데이터 구조를 입력받아 DOM 출력을 생성하여 사용자가 화면에서 볼 수 있도록 만듭니다. 우리는 이 프로세스를 rendering이라고 부르죠.</p>
<p><img src="/assets/images/angular/cd-4.svg" alt="" style="background-color:#0c4eb2"></p>
<p>하지만, 그것이 런타임에 변경이 발생하거나, DOM이 이미 랜더링된 얼마 후 일 경우에 처리가 까다로워집니다. Model에서 무엇이 바뀌 었는지, 그리고 DOM을 어디에서 업데이트해야하는지 어떻게 알 수 있을까요? DOM 트리에 액세스하는 것은 항상 비용이 많이 들기 때문에 업데이트가 필요한 위치를 알아야 하고, 액세스를 가능한 한 작게 유지해야 합니다.</p>
<p>이 이슈는 여러 가지 방법으로 해결할 수 있습니다. 한 가지 방법은 단순히 HTTP 요청을 하고 전체 페이지를 다시 렌더링하는 것입니다. 또 다른 접근법은 새로운 상태의 DOM을 이전 상태와 구분하여 차이점 만 렌더링하는 것입니다. ReactJS가 가상 DOM을 사용하여 수행하는 것처럼..</p>
<p>이와 관련해서 Tero는 <a href="http://teropa.info/blog/2015/03/02/change-and-its-detection-in-javascript-frameworks.html" target="_blank" rel="external">Change and its detection in JavaScript frameworks</a>라는 훌륭한 글을 썼습니다. 만일 당신이 프레임워크들이 어떻게 이 이슈를 해결하는지 좀 더 흥미가 있다면 이 글을 읽어보기를 추천합니다. 본 글에서는 Angular2 이상 버전에 대해서만 집중합니다.</p>
<p>기본적으로 변경 감지의 목표는 항상 데이터와 그 변화를 투영(projecting)하는 것입니다.</p>
<h3 id="무엇이-변화를-일으키는가"><a href="#무엇이-변화를-일으키는가" class="headerlink" title="무엇이 변화를 일으키는가?"></a>무엇이 변화를 일으키는가?</h3><p>자, 이제 우리는 변화 탐지가 무엇인지 알게되었으므로 정확히 언제 그러한 변화가 일어날 수 있는지 알아보겠습니다. Angular는 View를 업데이트 해야한다는 것을 언제 알 수 있을까요?<br>
undefined

</p>
<p>앵귤러 component를 처음 보는 경우 탭 <a href="https://blog.thoughtram.io/angular/2015/04/09/developing-a-tabs-component-in-angular-2.html" target="_blank" rel="external">component 작성에 대한 도움말</a>을 읽는 것이 좋습니다.</p>
<p>위의 component는 두 개의 속성(property)을 표시하고 템플릿의 button을 클릭 할 때 변경하는 메서드를 제공합니다. 이 특정 단추를 클릭하는 순간 application 상태(state)가 변경되면 component의 속성이 변경되기 때문입니다. 그 순간에 우리는 view를 업데이트하려고 합니다.</p>
<p>여기에 다른 코드가 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@Component()</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContactsApp</span> <span class="title">implements</span> <span class="title">OnInit</span></span>&#123;</div><div class="line"></div><div class="line">  contacts:Contact[] = [];</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(private http: Http) &#123;&#125;</div><div class="line"></div><div class="line">  ngOnInit() &#123;</div><div class="line">    <span class="keyword">this</span>.http.get(<span class="string">'/contacts'</span>)</div><div class="line">      .map(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</div><div class="line">      .subscribe(<span class="function"><span class="params">contacts</span> =&gt;</span> <span class="keyword">this</span>.contacts = contacts);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 component는 컨텐츠 목록을 가지고 있고, 그것이 초기화 되었을때 http 요청을 수행합니다. 이 요청이 다시 들어 오면 목록이 업데이트됩니다. 다시, 이 시점에서 application 상태가 변경되었으므로 view를 업데이트하려고 합니다.</p>
<p>기본적으로 application 상태 변화는 3가지에 의해 발생됩니다.</p>
<ul>
<li><strong>Events</strong> - click, submit, …</li>
<li><strong>XHR</strong> - 원격 데이터로부터 데이터를 가져오는 것</li>
<li><strong>Timers</strong> - <code>setTimeout()</code>, <code>setInterval()</code></li>
</ul>
<p>이것들은 모두 비동기입니다. 따라서 기본적으로 일부 비동기 작업이 수행 될 때마다 application 상태가 변경될 수 있다는 결론을 얻습니다. 이것은 누군가가 Angular에게 view를 업데이트 하라고 말해 줄 필요가 있을 때입니다.</p>
<h3 id="Angular에게-알리는-것은-무엇일까요"><a href="#Angular에게-알리는-것은-무엇일까요" class="headerlink" title="Angular에게 알리는 것은 무엇일까요?"></a>Angular에게 알리는 것은 무엇일까요?</h3><p>자, 이제 응용 프로그램 상태 변경의 원인을 알았습니다. 그러나 이 특정 순간에 view가 업데이트되어야 한다고 Angular에게 알리는 것은 무엇일까요?</p>
<p>Angular는 우리에게 native API(web의 경우 addEventListener 같은…)를 직접 사용하는 것을 허용합니다. Angular가 DOM을 업데이트 하는 알림을 받기 위해서, 우리가 호출 해야만하는 어떠한 가로채는(interceptor) methods도 없습니다. 이것은 마술일까요?</p>
<p>만일 최신 버젼의 글을 읽었다면, 당신은 이것을 처리하는 Zones을 알것입니다. 실제로, Angular는 <code>NgZone</code>이라는 자체 영역(zone)을 제공합니다. 우리는 <a href="https://blog.thoughtram.io/angular/2016/02/01/zones-in-angular-2.html" target="_blank" rel="external">Zones in Angular</a>라는 글을 기록 했었습니다.</p>
<p>Angular 소스 코드에서 <code>NgZones</code>, <code>onTurnDone</code> 이벤트를 수신하는 <code>ApplicationRef</code>라는 것이 있습니다. 이 이벤트가 발생하면, 본질적으로 변경 검출을 실시하는 <code>tick()</code> 함수를 실행합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 실제 Angular 코드의 매우 짧은 버젼</span></div><div class="line"><span class="keyword">class</span> ApplicationRef &#123;</div><div class="line"></div><div class="line">  changeDetectorRefs:ChangeDetectorRef[] = [];</div><div class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> zone: NgZone</span>) &#123;</div><div class="line">    <span class="keyword">this</span>.zone.onTurnDone.subscribe(() =&gt; <span class="keyword">this</span>.zone.run(() =&gt; <span class="keyword">this</span>.tick());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  tick() &#123;</div><div class="line">    <span class="keyword">this</span>.changeDetectorRefs</div><div class="line">      .forEach((ref) =&gt; ref.detectChanges());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Change-Detection"><a href="#Change-Detection" class="headerlink" title="Change Detection"></a>Change Detection</h3><p>좋습니다. 이제 변경 감지가 트리거되는 시점을 알 수 있지만 어떻게 수행될까요? Angular에서는 각 component마다 고유 한 변경 감지기가 있습니다.</p>
<p><img src="/assets/images/angular/cd-tree-2.svg" alt="" style="background-color:#0c4eb2"></p>
<p>이는 중요한 사실입니다. 이는 각 component에 대해 변경 감지가 수행되는 방법과시기를 개별적으로 제어 할 수 있기 때문입니다!</p>
<p>component 트리의 어딘가에 이벤트가 발생했다고 가정 해 봅시다. 버튼이 클릭되었을 수도 있습니다. 다음에 어떻게 될까요? 영역이 주어진 핸들러를 실행하고 턴이 완료되면 Angular에 알리고, 결국 Angular가 변경 감지를 수행한다는 것을 알았습니다.</p>
<p><img src="/assets/images/angular/cd-tree-7.svg" alt="" style="background-color:#0c4eb2"></p>
<p>각 component에는 고유 한 변경 감지기가 있고, Angular application은 component 트리로 구성되므로 결론적으로 변경 감지기 트리도 있다는 것입니다. 이 트리는 데이터가 항상 위에서 아래로 흐르는 방향 그래프로 볼 수도 있습니다.</p>
<p>데이터가 위에서 아래로 흐르는 이유는 root component부터 모든 단일 component에 대해 항상 변경 감지가 항상 위에서 아래로 수행되기 때문입니다. 단방향 데이터 흐름이 주기(cycles)보다 예측 가능하기 때문에 매우 좋습니다. 우리는 뷰에서 사용하는 데이터의 출처를 항상 알고 있습니다. 이는 해당 component에서만 발생할 수 있기 때문입니다.</p>
<p>또 다른 흥미로운 점은 변경 감지가 단일 패스(single pass) 후에 안정화된다는 것입니다. 즉, component 중 하나가 변경 감지 중에 첫 번째 실행 후 추가적인 부작용이 발생하면 Angular는 오류를 발생시킵니다.</p>
<h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><p>기본적으로 이벤트가 발생할 때마다 모든 단일 component를 검사해야 하더라도 Angular는 매우 빠릅니다. 몇 milliseconds 내에 수십만 개의 점검을 수행 할 수 있습니다. 이것은 Angular가 VM 친화적인 코드(VM friendly code)를 생성하기 때문에 가능합니다.</p>
<p>무슨 뜻일까요? 각 component마다 고유 한 변경 감지기가 있다는 것은, 각 개별 component의 변경 감지를 처리하는 Angular의 하나의 포괄적인 처리기(generic thing)가 있다는 것과 같은 의미가 아닙니다.</p>
<p>그 이유는 변경 감지기가 동적 방식으로 작성되어야 하기 때문에 모델 구조가 어떻든간에 모든 component를 확인할 수 있기 때문입니다. VM은 최적화 할 수 없다는 이유로 이런 종류의 동적 코드를 좋아하지 않습니다. 객체의 모양이 항상 동일하지는 않기 때문에 다형성(polymorphic)으로 간주됩니다.</p>
<p>Angular는 component 모델의 모양이 무엇인지 정확하게 알고 있기 때문에, 단일 component인 각 component의 런타임에 변경 감지기 클래스를 만듭니다. VM은이 코드를 완벽하게 최적화 할 수 있으므로 실행 속도가 매우 빠릅니다. 좋은 점은 Angular가 자동으로 처리하므로 너무 많이 신경 쓰지 않아도 된다는 것입니다.</p>
<h3 id="Smarter-Change-Detection"><a href="#Smarter-Change-Detection" class="headerlink" title="Smarter Change Detection"></a>Smarter Change Detection</h3><p>다시 말하지만, Angular는 이벤트가 발생할 때마다 모든 component를 확인해야합니다. 애플리케이션 상태가 변경되었을 수 있기 때문입니다. 그러나 Angular가 상태를 변경 한 application의 부분에 대해서만 변경 감지를 실행하도록 말할 수 있다면 좋지 않을까요?</p>
<p>그렇습니다. 할 수 있습니다! 무언가가 바뀌 었는지 여부에 대한 보장을 제공하는 데이터 구조(data structures)가 있습니다.</p>
<ul>
<li><strong>Immutables and Observables</strong> 이러한 structure 나 type을 사용하게되면 Angular에 알려줌으로써 변경 감지가 훨씬 더 빠를 수 있습니다. 그럼 어떻게 해야 할까요?</li>
</ul>
<h4 id="Understanding-Mutability"><a href="#Understanding-Mutability" class="headerlink" title="Understanding Mutability"></a>Understanding Mutability</h4><p>이유 및 방법을 이해하기 위해 불변의 데이터 구조(immutable data structures)가 도움이된다면, 우리는 변경 가능성(mutability)의 의미를 이해할 필요가 있습니다. 다음과 같은 component가 있다고 가정합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@Component(&#123;</div><div class="line">  <span class="attr">template</span>: <span class="string">'&lt;v-card [vData]="vData"&gt;&lt;/v-card&gt;'</span></div><div class="line">&#125;)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">VCardApp</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.vData = &#123;</div><div class="line">      <span class="attr">name</span>: <span class="string">'Christoph Burgdorf'</span>,</div><div class="line">      <span class="attr">email</span>: <span class="string">'christoph@thoughtram.io'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  changeData() &#123;</div><div class="line">    <span class="keyword">this</span>.vData.name = <span class="string">'Pascal Precht'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>VCardApp</code>는 <code>&lt;v-card&gt;</code>를 하위 component로 사용하며 이 component에는 <code>vData</code> 입력 속성이 있습니다. <code>VCardApp</code>의 <code>vData</code> 속성을 사용하여 해당 component로 데이터를 전달합니다. <code>vData</code>는 두 가지 속성을 가진 객체입니다. 또한 <code>vData</code>의 이름을 변경하는 <code>changeData()</code> 메서드가 있습니다. 여기에 별다른 신기한 점은 없습니다.</p>
<p>중요한 부분은 <code>changeData()</code>가 <code>name</code> 속성을 변경하여 <code>vData</code>를 변경한다는 점입니다. 해당 속성이 변경 되더라도 <code>vData</code> 참조 자체는 그대로 유지됩니다.</p>
<p>어떤 이벤트로 인해 <code>changeData()</code>가 실행된다고 가정하고, 변경 감지가 수행 될 때 어떤 일이 발생할까요? 먼저 <code>vData.name</code>이 변경된 다음 <code>&lt;v-card&gt;</code>로 전달됩니다. <code>&lt;v-card&gt;</code>의 변경 감지기는 이제 <code>vData</code>가 이전과 여전히 동일한지 확인합니다. 참조(reference)는 변경되지 않았습니다. 그러나 <code>name</code> 속성이 변경되었으므로 Angular는 해당 객체에 대한 변경 감지를 수행합니다.</p>
<p>자바 스크립트에서는 객체가 기본적으로 변경 가능하기 때문에 (프리미티브(primitives) 제외) Angular는 보수적이어야하며 이벤트가 발생할 때마다 모든 component에 대해 변경 감지를 실행해야합니다.</p>
<p>다음은 불변의(immutable) 데이터 구조가 작동하는 곳입니다.</p>
<h3 id="Immutable-Objects"><a href="#Immutable-Objects" class="headerlink" title="Immutable Objects"></a>Immutable Objects</h3><p>변경할 수 없는 객체는 객체 불변을 보장해 줍니다. 즉, 불변 객체를 사용하고 그러한 객체를 변경하고자 할 때, 원래 객체가 변경되지 않기 때문에 우리는 항상 그 변경으로 새로운 참조를 얻습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> vData = someAPIForImmutables.create(&#123;</div><div class="line">              <span class="attr">name</span>: <span class="string">'Pascal Precht'</span></div><div class="line">            &#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> vData2 = vData.set(<span class="string">'name'</span>, <span class="string">'Christoph Burgdorf'</span>);</div><div class="line"></div><div class="line">vData === vData2 <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p><code>someAPIForImmutables</code>는 변경 불가능한 데이터 구조에 사용하려는 모든 API가 될 수 있습니다. 그러나 예제에서 볼 수 있듯이 단순히 name 속성을 변경할 수는 없습니다. 우리는 그 특별한 변화를 가진 새로운 객체를 얻게 될 것이고 이 객체는 새로운 참조를 가지고 있습니다.</p>
<h3 id="점검-횟수-줄이기-Reducing-the-number-of-checks"><a href="#점검-횟수-줄이기-Reducing-the-number-of-checks" class="headerlink" title="점검 횟수 줄이기(Reducing the number of checks)"></a>점검 횟수 줄이기(Reducing the number of checks)</h3><p>Angular는 입력 속성이 변경되지 않을 때 전체 변경 감지 하위 트리를 건너 뛸 수 있습니다. 우리는 방금 “변화”가 “새로운 참조”를 의미한다는 것을 배웠습니다. Angular 앱에서 불변 객체를 사용하는 경우, 입력 값이 변경되지 않은 경우 component가 변경 감지를 건너 뛸 수 있다고 Angular에 알려주면됩니다.</p>
<p><code>&lt;v-card&gt;</code>를 통해 어떻게 작동하는지 봅시다.<br>
undefined

<br>보시다시피, <code>VCardCmp</code>는 입력 속성에만 의존합니다. 좋습니다. 변경 감지 전략을 다음과 같이 <code>OnPush</code>로 설정하여 입력이 변경되지 않으면 이 component의 하위 트리에 대한 변경 감지를 건너 뛰도록 Angular에 지시 할 수 있습니다.<br>
undefined

<br>이게 전부입니다! 이제 더 큰 component 트리를 상상해보십시오. 불변 객체를 사용하고, Angular에 적절하게 정보가 전달되면 전체 하위 트리를 건너 뛸 수 있습니다.</p>
<p><img src="/assets/images/angular/cd-tree-8.svg" alt="" style="background-color:#0c4eb2"></p>
<h3 id="Observables"><a href="#Observables" class="headerlink" title="Observables"></a>Observables</h3><p>이전에 언급 한 바와 같이 Observables는 변경 사항이 언제 발생했는지 확실하게 보장합니다. 불변 객체와는 달리, 변경 사항이있을 때 새로운 참조(references)를 제공하지 않습니다.<br>대신, Observables은 그들에게 반응하기 위해 우리가 구독 할 수 있는 이벤트를 제공합니다.</p>
<p>만일 우리가 Observables을 사용하고, 우리가 변경 감지 하위트리를 건너뛰기 위해서 <code>OnPush</code>를 사용하기를 원한다 할 때, 이러한 객체의 참조가 변경되지 않으면 어떻게 처리해야 할까요? Angular는 component 트리의 경로에서 특정 이벤트를 검사 할 수 있는 매우 현명한 방법을 제공합니다.</p>
<p>이것이 의미하는 것을 이해하기 위해 아래의 component를 살펴 보겠습니다.<br>
undefined

</p>
<p>장바구니가있는 e-commerce 애플리케이션을 구축한다고 가정 해 보겠습니다. 사용자가 장바구니에 제품을 올릴 때마다 우리는 UI에 작은 카운터를 표시하여 카트의 제품 수량을 볼 수 있습니다.</p>
<p><code>CartBadgeCmp</code>의 역할이 그것입니다. 제품에는 장바구니에 제품이 추가 될 때마다 실행되는 이벤트 스트림 인 <code>counter</code> 와 입력 속성 <code>addItemStream</code>이 있습니다.</p>
<p>우리는 이 글에서 observables이 어떻게 작동하는지에 대해 자세히 설명하지 않을 것입니다. observables에 대해 더 자세히 알고 싶다면 <a href="http://blog.thoughtram.io/angular/2016/01/06/taking-advantage-of-observables-in-angular2.html" target="_blank" rel="external">Observables in Angular를 활용하는 방법에 대한 글</a>를 읽어보세요.</p>
<p>또한 변경 검색 전략을 <code>OnPush</code>로 설정하므로, 오직 component의 입력 속성이 변경될 때만 변경 감지가 수행됩니다.</p>
<p>그러나 앞에서 언급했듯이 <code>addItemStream</code>의 참조는 변경되지 않으므로 이 component의 하위 트리에 대한 변경 감지가 수행되지 않습니다. component가 <code>ngOnInit</code> 라이프 사이클 hook에서 해당 스트림을 subscribe하고 카운터를 증가시키기 때문에 이는 문제가됩니다. 이것은 응용 프로그램 상태 변경이며 이를 반영하고 싶습니다.</p>
<p>변경 탐지기 트리가 어떻게 생겼는지 (모든 것을 OnPush로 설정했습니다) 이벤트가 발생하면 변경 감지가 수행되지 않습니다.</p>
<p><img src="/assets/images/angular/cd-tree-10.svg" alt="" style="background-color:#0c4eb2"></p>
<p>이 변화에 대해 Angular에게 어떻게 알릴 수 있습니까? 전체 트리가 OnPush로 설정된 경우에도이 component에 대해 변경 감지를 수행해야한다는 Angular를 어떻게 알 수 있습니까?</p>
<p>걱정 마세요. Angular는 우리에게 적용됩니다. 앞서 학습 한 것처럼 변경 감지는 항상 위에서 아래로 수행됩니다. 따라서 우리는 변경이 발생한 component에 대한 트리의 전체 경로에 대한 변경을 감지하는 방법이 필요합니다. Angular는 어느 경로인지 알 수 없지만 우리는 알수 있습니다.</p>
<p>우리는 <code>markForCheck()</code>라는 API와 함께 제공되는 의존성 삽입을 통해 컴포넌트의 <code>ChangeDetectorRef</code>에 액세스 할 수 있습니다. 이 방법은 우리가 필요로하는 것을 정확히 수행합니다! 다음 변경 감지 실행을 위해 루트까지 component의 경로를 표시합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constructor</span>(private cd: ChangeDetectorRef) &#123;&#125;</div></pre></td></tr></table></figure>
<p>그런 다음 Angular에 이 component의 경로를 확인할 루트까지 표시하도록 지시합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">  ngOnInit() &#123;</div><div class="line">    <span class="keyword">this</span>.addItemStream.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">this</span>.counter++; <span class="comment">// application state changed</span></div><div class="line">      <span class="keyword">this</span>.cd.markForCheck(); <span class="comment">// marks path</span></div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>다됐습니다! observable 이벤트가 시작된 후, 변경 감지 시작 전의 모습은 다음과 같습니다.</p>
<p><img src="/assets/images/angular/cd-tree-12.svg" alt="" style="background-color:#0c4eb2"></p>
<p>이제 변경 감지가 수행되면 단순히 위에서 아래로 이동합니다.</p>
<p><img src="/assets/images/angular/cd-tree-13.svg" alt="" style="background-color:#0c4eb2"></p>
<p>멋지죠? 변경 감지 실행이 끝나면 전체 트리의 <code>OnPush</code> 상태를 복원합니다.</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/01/27/angular-detection/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/01/01/rxjs-trans-operator/">
                            RxJS Transformation Operator
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-01-01T16:34:43+09:00">
	
		    1월 01, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/RxJS/">RxJS</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h3 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h3><p>buffer는 말그대로 Obervable의 실행을 일정기간 미루는 것이다. 시리즈 성격의 buffer Operators는 몇가지가 있는데, 이들 모두 공통적으로 Obervable의 실행을 일정기간 미룬다.</p>
<h4 id="buffer-1"><a href="#buffer-1" class="headerlink" title="buffer"></a>buffer</h4><p>Obervable을 인자로 받으며, 인자의 Obervable이 subscribe될 때 미루고 있던 이전의 Obervable의 subscribe값들을 배열로 반환한다.  </p>
<p>아래 예재에서는 document 클릭할때마다 1초마다 쌓인 스트림을 배열로 반환 한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obBuffer = Rx.Observable.interval(<span class="number">1000</span>)</div><div class="line">  .buffer(Rx.Observable.fromEvent(<span class="built_in">document</span>,<span class="string">'click'</span>));</div><div class="line">obBuffer.subscribe(<span class="function"><span class="params">x</span>=&gt;</span><span class="built_in">console</span>.log(x));</div></pre></td></tr></table></figure></p>
<h4 id="bufferCount"><a href="#bufferCount" class="headerlink" title="bufferCount"></a>bufferCount</h4><p>bufferCount는 두개의 인자를 받는다. 첫 번째는 도출되는 buffer의 최대 사이즈가 오며, 두 번째는 새로운 buffer가 몇번의 스트림을 주기로 실행될것인지가 온다. 즉 bufferCount(3,2)라면 여기서 도출되는 스트림은, input Observable의 스트림중 최근 3개를 인자로 묶은 배열이 2번의 주기로 실행되는 것이다.(말이 어렵다… ㅠ)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obBufferCount = Rx.Observable.interval(<span class="number">1000</span>)</div><div class="line">  .bufferCount(<span class="number">3</span>, <span class="number">4</span>);</div><div class="line">obBufferCount.subscribe(<span class="function"><span class="params">x</span>=&gt;</span><span class="built_in">console</span>.log(x)); <span class="comment">//[0,1,2], [4,5,6] ...</span></div></pre></td></tr></table></figure>
<h4 id="bufferTime"><a href="#bufferTime" class="headerlink" title="bufferTime"></a>bufferTime</h4><p>Observable 값을 특정 시간단위로 지연시켜 배출한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obBufferTime = Rx.Observable.interval(<span class="number">1000</span>).bufferTime(<span class="number">3000</span>);</div><div class="line">obBufferTime.subscribe(<span class="function"><span class="params">x</span>=&gt;</span><span class="built_in">console</span>.log(x)); <span class="comment">//[0, 1], [2,3,4], [5,6,7]</span></div></pre></td></tr></table></figure></p>
<h4 id="bufferToggle"><a href="#bufferToggle" class="headerlink" title="bufferToggle"></a>bufferToggle</h4><p>bufferToggle은 두개의 인자를 받는다. 첫 번째는 buffer를 시작하는, 두 번째는 buffer를 마무리 하기 위한 인자가 온다. 첫 번째는 구독가능하거나 Promise로 반환되는(Subscribable Or Promise) 값이오고, 두 번째는 구독가능하거나 Promise로 반환되는(Subscribable Or Promise) 값을 도출하는 함수가 온다. 결국 두개의 Observable을 인자로 받아 시작점과 끝나는 지점을 정하고 이 안에 있는 스트림을 배열로 묶어 배출한다. 만일 promise라면 resolve함수가 실행되는 시점이 시작하거나 마무리하는 시점이 되며, 이는 시점을 정할뿐 인자를 넘겨 줄 수 없다(아마도….)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obBufferToggle = Rx.Observable.interval(<span class="number">1000</span>) <span class="comment">//1초에 1씩 증가하는 값을 반환하는 스트림</span></div><div class="line">  .bufferToggle(Rx.Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'click'</span>), (e)=&gt;&#123; <span class="comment">//시작 시점은 문서를 클릭할때</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">res, rej</span>)</span>&#123;</div><div class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span>&#123;</div><div class="line">        res(<span class="number">100</span>)<span class="comment">//인자는 쓰이지 않는다...?</span></div><div class="line">      &#125;, <span class="number">2000</span>)</div><div class="line">    &#125;)<span class="comment">//끝나는 시점은 2초가 지난 후.</span></div><div class="line">  &#125;);</div><div class="line">obBufferToggle.subscribe(<span class="function"><span class="params">x</span>=&gt;</span><span class="built_in">console</span>.log(x)); <span class="comment">//[n, n+1], [m, m+1]...</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><h4 id="map-1"><a href="#map-1" class="headerlink" title="map"></a>map</h4><p><a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-map" target="_blank" rel="external">map</a>은 Array method들 중에 가장 많이 쓰이는 것 중에 하나이다. RxJS의 맵도 거의 같은 역할을 한다. 차이점이라면 Array method는 배열의 인자를 순회하면서 콜백 함수에 의한 값을 리턴하는 반면, RxJS의 map은 스트림 값을 받아 콜백함수에 의한 값을 그대로 흘려보내준다는 것이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obMap = Rx.Observable.from([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</div><div class="line">  .map(<span class="function"><span class="params">x</span> =&gt;</span> x+<span class="number">10</span>);</div><div class="line">obMap.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x)); <span class="comment">// 11, 12, 13, 14</span></div></pre></td></tr></table></figure></p>
<h4 id="mapTo"><a href="#mapTo" class="headerlink" title="mapTo"></a>mapTo</h4><p><a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-mapTo" target="_blank" rel="external">mapTo</a>는 map과 거의 유사하다. 하지만 아웃풋 값이 mapTo의 인자 값으로 고정이다. 다음에 나오는 operator들에도 뒤에 to가 붙는 것들이 있는데, 대부분 기본 operator 기능에 인자 값을 subscribe로 넘기는 비슷한 역할을 한다.  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obMapTo = Rx.subscribe.from([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</div><div class="line">  .mapTo(<span class="string">'10'</span>);</div><div class="line">obMapTo.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x)); <span class="comment">//10, 10, 10, 10</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="concatMap-exhaustMap-mergeMap-switchMap"><a href="#concatMap-exhaustMap-mergeMap-switchMap" class="headerlink" title="concatMap exhaustMap mergeMap switchMap"></a>concatMap exhaustMap mergeMap switchMap</h3><p>이 Operator들은 인자로 Observable을 받는다. 그리고 인풋의 Observable과 인자의 Observable을 합쳐(flat) 하나의 스트림을 반환한다. 두 번째 인자로는 콜백함수를 포함시킬 수 있다. 인자로는 총 4개를 받는데, <code>Outer Observable의 값</code>, <code>Inner Observable의 값</code>, <code>Outer Observable의 Index</code>, <code>Inner Observable의 Index</code>로 구성된다. 각각은 다음과 같은 특징을 가지고 있다.</p>
<ul>
<li><code>concat</code> Observable이 끝나면 이어서 다음 Observable을 실행. 첫 번째 Observable이 끝나기 에 두 번째 Observable이 실행해도 첫 번째 Observable이 끝나고 나서 두 번째가 실행된다.</li>
<li><code>exhaust</code> Observable이 실행되고 있을때 실행되는 다음 Observable을 무시한다.</li>
<li><code>merge</code> Observable이 발생하는대로 모두 실행한다. (<code>flatMap</code>과 동일한 것으로 보인다.)</li>
<li><code>switch</code> Observable이 실행되고 있을때 다음 Observable이 실행되면 먼저실행된 Observable을 중단시킨다.</li>
</ul>
<p>모든 Operator가 비슷하게 작동하므로 소스예제는 하나만 기록한다. 중간에 Operator만 바꾸면 작동한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> clicks = Rx.Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'click'</span>);</div><div class="line"><span class="keyword">const</span> higherOrder = clicks.concatMap(<span class="function"><span class="params">ev</span> =&gt;</span> Rx.Observable.interval(<span class="number">1000</span>).take(<span class="number">3</span>), (i,j,k,l) =&gt; &#123;</div><div class="line">  <span class="keyword">return</span> [i,j,k,l];</div><div class="line">&#125;);</div><div class="line">higherOrder.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</div></pre></td></tr></table></figure>
<hr>
<h3 id="window"><a href="#window" class="headerlink" title="window"></a>window</h3><p><a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-window" target="_blank" rel="external">window</a>는 Transformation Operator중 개념 이해하기가 가장 난해했다. 결과적으로 이야기 하면… Outer Observable이 발생할 때마다 Inner Observable을 각각의 Observable(window)로 쪼개서 배출한다. 이는 마치 자바스크립트의 <code>split</code> method와 비슷하다.<br><code>window</code>로 시작하는 Operator들이 몇가지 있는데 기본 동작 원칙은 같다. 한 Observable의 스트림을 기반으로 새로운 Observable들을 반환한다. 그리고 이 Operator의 인자로 언제 새로운 Observable을 만들고, 언제 없앨지를 정한다.</p>
<p>아래 소스에서는 2초마다 스트림이 발생하는 Observable(interval)이 있고, 각 스트림이 실행될 때 마다 클릭 이벤트를 바라보는 Observable(clicks)이 생성된다. 이 clicks는 스트림이 끝날 때 같이 종료된다. 또한 clicks은 한 스트림 안에서 2번까지의 클릭만 스트림을 발생시킨다. 다소 복잡할 수 있지만 아래의 소스를 이해한다면 window의 개념을 어느정도 잡을 수 있을 것이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> clicks = Rx.Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'click'</span>);</div><div class="line"><span class="keyword">const</span> interval = Rx.Observable.interval(<span class="number">2000</span>);</div><div class="line"><span class="keyword">const</span> result = clicks.window(interval) <span class="comment">//2초마다 클릭 이벤트를 바라보는 Observable(윈도우)틀 배출한다.</span></div><div class="line">  .map(<span class="function"><span class="params">win</span> =&gt;</span> win.take(<span class="number">2</span>)) <span class="comment">// 각 윈도우는 2개의 스트림만을 받는다.</span></div><div class="line">result.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'out'</span>);<span class="comment">//2초마다 클릭이벤트 Observable 발생</span></div><div class="line">  x.subscribe(</div><div class="line">    <span class="function"><span class="params">y</span> =&gt;</span> <span class="built_in">console</span>.log(y),<span class="comment">//클릭할때 스트림 발생</span></div><div class="line">    err =&gt; <span class="built_in">console</span>.log(err),</div><div class="line">    () =&gt; <span class="built_in">console</span>.log(<span class="string">'finish'</span>)<span class="comment">//2번의 클릭 스트림 발생했거나 2초가 지났으면 complete매소드 실행</span></div><div class="line">  )&#125;</div><div class="line">);</div></pre></td></tr></table></figure></p>
<h4 id="windowCount"><a href="#windowCount" class="headerlink" title="windowCount"></a>windowCount</h4><p><a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-windowCount" target="_blank" rel="external">windowCount</a>는 인자로 숫자를 받는다. 이 숫자 개수만큼 Outer Observable의 스트림을 묶어서 하나의 Observable로 분출한다. 위에서 살펴본 인자의 숫자만큼 대기한다는 측면에서 <code>bufferCount</code>과 매칭된다.</p>
<p>아래 소스는 클릭 스트림이 3번 쌓일때마다 클릭 Observable을 complete하고 새로운 클릭 스트림을 만든다. (순수함수라는 측면에서 전역변수를 쓰는건 안좋은 방법이지만 이해를 돕기위해 cnt라는 전역변수를 만들었다.)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> cnt = <span class="number">0</span>;</div><div class="line"><span class="keyword">const</span> clicks = Rx.Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'click'</span>);</div><div class="line"><span class="keyword">const</span> result = clicks.windowCount(<span class="number">3</span>)</div><div class="line">result.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'click Observable Start'</span>); <span class="comment">//클릭 Observable 생성</span></div><div class="line">  x.subscribe(</div><div class="line">    <span class="function"><span class="params">y</span> =&gt;</span> <span class="built_in">console</span>.log(++cnt),<span class="comment">//클릭할때마다 숫자 1씩 증가</span></div><div class="line">    e =&gt; e,</div><div class="line">    () =&gt; (cnt = <span class="number">0</span>, <span class="built_in">console</span>.log(<span class="string">'click Observable completed'</span>)) <span class="comment">//클릭 Observable 종료</span></div><div class="line">  ),</div><div class="line">  e =&gt; e,</div><div class="line">  () =&gt; (<span class="built_in">console</span>.log(<span class="string">'completed'</span>));</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h4 id="windowTime"><a href="#windowTime" class="headerlink" title="windowTime"></a>windowTime</h4><p><a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-windowTime" target="_blank" rel="external">windowTime</a>는 인자로 두개의 숫자를 받는다, 첫번째는 생성된 window가 지속될 시간이고, 두번째는 window의 생성 주기를 나타내는 시간이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> clicks = Rx.Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'click'</span>);</div><div class="line"><span class="keyword">const</span> result = clicks.windowTime(<span class="number">2000</span>, <span class="number">5000</span>) <span class="comment">//Observable이 2초후 종료됨. Observable생성 5초 후에 새로운 Observable이 시작.</span></div><div class="line">  .map(<span class="function"><span class="params">win</span> =&gt;</span> win.take(<span class="number">2</span>)) <span class="comment">// 각 윈도우는 2개의 스트림만을 받는다.</span></div><div class="line">result.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'start'</span>)</div><div class="line">  x.subscribe(</div><div class="line">    <span class="function"><span class="params">y</span> =&gt;</span> <span class="built_in">console</span>.log(y), <span class="comment">//클릭할때 스트림 발생</span></div><div class="line">    err =&gt; <span class="built_in">console</span>.log(err),</div><div class="line">    () =&gt; <span class="built_in">console</span>.log(<span class="string">'finish'</span>) <span class="comment">//2초가 지나거나 클릭 스트림이 2번 발생할경우 complete</span></div><div class="line">  )</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="windowToggle"><a href="#windowToggle" class="headerlink" title="windowToggle"></a>windowToggle</h4>
                    
                        
                    
                    
                        <p>
                            <a href="/2017/01/01/rxjs-trans-operator/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">page 1 of 1</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2017 Owen. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <h4 id="about-card-name">Owen</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-close"></i></span>
            <a href="https://algolia.com" target="_blank" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    autofocus="autofocus"/>
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">no post found</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://wooner.net/2016/07/12/prototype/">
                            <h3 class="media-heading">객체 및 프로토타입</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 7월 12일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://wooner.net/2016/07/12/fill-image-css/">
                            <h3 class="media-heading">프레임에 이미지 꽉 채우기 Part2(css)</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 7월 12일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://wooner.net/2016/07/12/fill-image-javascript/">
                            <h3 class="media-heading">프레임에 이미지 꽉 채우기 Part2(Javascript)</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 7월 12일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://wooner.net/2016/08/10/prototype/">
                            <h3 class="media-heading">자바스크립트 프로토 타입의 프로퍼티 할당</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 8월 10일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://wooner.net/2016/08/12/array-object/">
                            <h3 class="media-heading">객체와 배열 구분하기</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 8월 12일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://wooner.net/2016/08/18/develop-patten/">
                            <h3 class="media-heading">다른 퍼블리셔들의 사용패턴 설문조사</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 8월 18일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://wooner.net/2016/08/21/valueof-tostring/">
                            <h3 class="media-heading">Javascript의 valueOf, toString</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 8월 21일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://wooner.net/2016/08/22/javascript-jsonp/">
                            <h3 class="media-heading">JSONP에 관하여...</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 8월 22일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://wooner.net/2016/08/28/javascript-reduce/">
                            <h3 class="media-heading">ECMA5 javascript method : reduce</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 8월 28일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://wooner.net/2016/09/01/javascript-map/">
                            <h3 class="media-heading">ECMA5 javascript method : map</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 9월 1일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="no post found"
                data-message-one="1 post found"
                data-message-other="{n} posts found">
                22 posts found
            </p>
        </div>
    </div>
</div>
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/jquery.fancybox-thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->



    </body>
</html>
