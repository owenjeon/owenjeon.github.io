
<!DOCTYPE html>
<html lang="ko">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Owen&#39;s Blog">
    <title>Archives: 2017/2 - Owen&#39;s Blog</title>
    <meta name="author" content="Owen">
    
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <meta property="og:type" content="blog">
<meta property="og:title" content="Owen's Blog">
<meta property="og:url" content="https://owenjeon.github.io/archives/2017/02/index.html">
<meta property="og:site_name" content="Owen's Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Owen's Blog">
    
    
        
    
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-gkdwv6gpmsvziyqj09onb2nm8pqnf9m6mfclab1sabtzip0qozttwf89jomo.min.css">
    <!--STYLES END-->
    
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">Owen&#39;s Blog</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/atom.xml"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/02/28/angular-resolve/">
                            Angular2 Resolve
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-02-28T12:34:00+09:00">
	
		    2월 28, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Angular/">Angular</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p><strong>이 글은 <a href="https://blog.thoughtram.io/angular/2016/10/10/resolving-route-data-in-angular-2.html" target="_blank" rel="external">Thoughtram 블로그</a>를 참고하여 작성한 것입니다.</strong></p>
<p>Angular의 router를 이용하면 쉽게 페이지 전환을 할 수 있습니다. 하지만 좀 더 완벽히 구동되는 application을 만들기 위해서 router는 해결해야 할 문제점이 하나 있습니다. 바로 바인딩되는 데이터 로딩이 라우터가 실행보다 빠르게 완료되는 것이 보장되지 않는다는 것입니다. 예를들어 http통신을 통해 api로 특정 데이터를 가져오고, 이를 화면에 뿌린다고 했을때, http통신은 비동기이기 때문에 라우터가 먼저 실행되고 나서 얼마 후에 데이터 도착하면 view가 rendering 됩니다. 이 때문에 사용자들은 가끔 데이터가 듬성듬성 빠져있는 화면을 잠깐동안 보게 됩니다.</p>
<p>이를 해결하는 방법은 여러가지가 있습니다(데이터가 들어오기 전까지 host경로에 <code>ngIf</code>를 <code>false</code>로 한다는 등의…). 여기서는 <strong>Route의 resolver를</strong> 통해 문제를 해결해 보려고 합니다.</p>
<h3 id="무엇이-문제일까요"><a href="#무엇이-문제일까요" class="headerlink" title="무엇이 문제일까요?"></a>무엇이 문제일까요?</h3><p>자, contact 애플리케이션을 만들어 봅시다. 우리는 <code>contacts list</code>와 <code>contacts detail</code>을 위한 라우터를 가지고 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Routes &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</div><div class="line"><span class="keyword">import</span> &#123; ContactsListComponent &#125; <span class="keyword">from</span> <span class="string">'./contacts-list'</span>;</div><div class="line"><span class="keyword">import</span> &#123; ContactsDetailComponent &#125; <span class="keyword">from</span> <span class="string">'./contacts-detail'</span>;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> AppRoutes: Routes = [</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">''</span>, <span class="attr">component</span>: ContactsListComponent &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'contact/:id'</span>, <span class="attr">component</span>: ContactsDetailComponent &#125;</div><div class="line">];</div></pre></td></tr></table></figure>
<p>그리고 당연히 우리는 해당 라우터를 탑재한 루트모듈이 필요합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</div><div class="line"><span class="keyword">import</span> &#123; BrowserModule &#125; <span class="keyword">from</span> <span class="string">'@angular/platform-browser'</span>;</div><div class="line"><span class="keyword">import</span> &#123; RouterModule &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</div><div class="line"><span class="keyword">import</span> &#123; AppRoutes &#125; <span class="keyword">from</span> <span class="string">'./app.routes'</span>;</div><div class="line"></div><div class="line">@NgModule(&#123;</div><div class="line">  <span class="attr">imports</span>: [</div><div class="line">    BrowserModule,</div><div class="line">    RouterModule.forRoot(AppRoutes)</div><div class="line">  ],</div><div class="line">  ...</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>여기까지 특별할 것은 없습니다. 만일 이 소스가 낯설다면 라우팅에 관한 <a href="https://angular.io/docs/ts/latest/tutorial/toh-pt5.html" target="_blank" rel="external">다른 글</a>을 먼저 읽으시는걸 권장합니다.</p>
<p><code>ContactsDetailComponent</code>을 살펴 봅시다. 이 컴포넌트는 contact data를 보여주는 역할을 가지고 있습니다. 따라서 route URL에서 제공되는 <code>id</code>값(route에서 <code>:id</code>로 포현되는 파라미터)을 가지고 <code>contact object</code>에 접근해야 합니다. <code>ActivatedRoute</code>를 통해서 쉽게 route parameter에 접근 할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</div><div class="line"><span class="keyword">import</span> &#123; ActivatedRoute &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</div><div class="line"><span class="keyword">import</span> &#123; ContactsService &#125; <span class="keyword">from</span> <span class="string">'../contacts.service'</span>;</div><div class="line"><span class="keyword">import</span> &#123; Contact &#125; <span class="keyword">from</span> <span class="string">'../interfaces/contact'</span>;</div><div class="line"></div><div class="line">@Component(&#123;</div><div class="line">  <span class="attr">selector</span>: <span class="string">'contacts-detail'</span>,</div><div class="line">  <span class="attr">template</span>: <span class="string">'...'</span></div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ContactsDetailComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</div><div class="line"></div><div class="line">  contact: Contact;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(</div><div class="line">    private contactsService: ContactsService,</div><div class="line">    private route: ActivatedRoute</div><div class="line">  ) &#123;&#125;</div><div class="line"></div><div class="line">  ngOnInit() &#123;</div><div class="line">    <span class="keyword">let</span> id = <span class="keyword">this</span>.route.snapshot.params[<span class="string">'id'</span>];</div><div class="line">    <span class="keyword">this</span>.contactsService.getContact(id)</div><div class="line">        .subscribe(<span class="function"><span class="params">contact</span> =&gt;</span> <span class="keyword">this</span>.contact = contact);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>좋습니다. <code>ContactsDetailComponent</code>는 받은 <code>id</code>를 가지고 <code>contact</code> 객체를 가져오고, 로컬 <code>contact</code> property에 제공합니다. 그리고 `{{contact.name}}`같은 표현을 통해 컴포넌트의 템플릿에 값을 삽입합니다.<br>컴포넌트의 템플릿을 살펴봅시다!</p>

undefined


<p><code>contact</code>객체 뒤에 물음표(?)를 붙였습니다. 이를 Safe Navigation Operators(SNO)라고 부릅니다. 이는 만일 비동기로 <code>contact</code> 데이터를 바인딩한다면, 컴포넌트가 초기화될때 <code>contact</code>는 <code>undefined</code>이기 때문에, 프로퍼티를 가질 수 없어 에러를 내는 것을 방지하기 위한 표현입니다.<br>이 이슈를 구현하기 위해서, <code>ContactsService#getContact()</code>에 3초 딜레이를 주고 <code>contact</code> 오브젝트를 내보내겠습니다. <code>RxJS</code>의 <code>delay</code> 오퍼레이터를 쓰면 쉽게 구현할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</div><div class="line"></div><div class="line">@Injectable()</div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ContactsService</span> </span>&#123;</div><div class="line"></div><div class="line">  getContact(id) &#123;</div><div class="line">    <span class="keyword">return</span> Observable.of(&#123;</div><div class="line">      <span class="attr">id</span>: id,</div><div class="line">      <span class="attr">name</span>: <span class="string">'Pascal Precht'</span>,</div><div class="line">      <span class="attr">website</span>: <span class="string">'http://thoughtram.io'</span>,</div><div class="line">    &#125;).delay(<span class="number">3000</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>템플릿 마다 SNO를 모든 곳에 추가하는 것도 상당히 힘든 일이 될 수 있습니다. 그 외에도 <code>NgModel</code> 및 <code>RouterLink</code> Directive와 같은 일부 연산자는 SNO를 지원하지 않습니다. 이제 <code>route resolver</code>를 사용하여 어떻게 해결할 수 있는지 살펴 보겠습니다.</p>
<h3 id="resolver의-정의"><a href="#resolver의-정의" class="headerlink" title="resolver의 정의"></a>resolver의 정의</h3><p><code>route resolvers</code>는 route가 활성화 되기전에, route에게 필요한 데이터를 제공하는 것을 도와줍니다. <code>resolver</code>를 생성하는 것은 여러 방법이 있습니다. 우리는 가장 쉬운것 부터 시작할 것입니다. <code>resolver</code>는 <code>Observable&lt;any&gt;</code>, <code>Promise&lt;any&gt;</code> 또는 단지 데이터를 반환하는 함수입니다.</p>
<p>Resolver는 Angular Module의 <code>providers</code>에 등록되어야 합니다.</p>
<p>여기에 static한 <code>contact</code> object를 반환하는 resolver 함수가 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@NgModule(&#123;</div><div class="line">  ...</div><div class="line">  providers: [</div><div class="line">    ContactsService,</div><div class="line">    &#123;</div><div class="line">      <span class="attr">provide</span>: <span class="string">'contact'</span>,</div><div class="line">      <span class="attr">useValue</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">          <span class="attr">id</span>: <span class="number">1</span>,</div><div class="line">          <span class="attr">name</span>: <span class="string">'Some Contact'</span>,</div><div class="line">          <span class="attr">website</span>: <span class="string">'http://some.website.com'</span></div><div class="line">        &#125;;</div><div class="line">      &#125;</div><div class="line">  ]&#125;</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>우리는 <code>resolver</code>가 사용될때 항상 같은 <code>contact</code> object가 반환되는걸 바라지 않습니다. 우리는 Angular의 <code>dependency injection(DI, 의존성 주입)</code>를 사용해서 간단한 <code>resolver</code> 함수를 등록할 수 있습니다. 어떻게 이 <code>resolver</code>를 <code>route</code>에 연결하면 될까요? resolve 프로퍼티를 <code>resolver</code>를 사용할 route 구성안에 추가하면 됩니다.</p>
<p>아래는 어떻게 우리의 <code>resolver</code> 함수를 <code>route</code> 구성에 추가하는지 보여줍니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> AppRoutes: Routes = [</div><div class="line">  ...</div><div class="line">  &#123;</div><div class="line">    <span class="attr">path</span>: <span class="string">'contact/:id'</span>,</div><div class="line">    <span class="attr">component</span>: ContactsDetailComponent,</div><div class="line">    <span class="attr">resolve</span>: &#123;</div><div class="line">      <span class="attr">contact</span>: <span class="string">'contact'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">];</div></pre></td></tr></table></figure>
<p>이게 다인가요? 네 맞습니다! <code>&#39;contact&#39;</code>는 <code>resolver</code>를 route 구성에 추가할때에 참고하는 <code>provider</code> 토큰입니다.</p>
<p>이제 우리가해야 할 일은 <code>ContactsDetailComponent</code>가 <code>contact</code> 객체를 유지하는 방법을 변경하는 것입니다. <strong>route resolvers를</strong> 통해 전달되는 모든 것은 <code>ActivatedRoute</code>의 데이터 속성에 노출됩니다. 즉, 이제 우리는 다음과 같이 <code>ContactsService</code> 종속성(dependency)을 제거 할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@Component()</div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ContactsDetailComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</div><div class="line"></div><div class="line">  contact;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(private route: ActivatedRoute) &#123;&#125;</div><div class="line"></div><div class="line">  ngOnInit() &#123;</div><div class="line">    <span class="keyword">this</span>.contact = <span class="keyword">this</span>.route.snapshot.data[<span class="string">'contact'</span>];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>사실, resolver함수를 정의하면, 우리는 <code>RouterStateSnapshot</code>뿐 아니라 <code>ActivatedRouteSnapshot</code>에도 접근할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@NgModule(&#123;</div><div class="line">  ...</div><div class="line">  providers: [</div><div class="line">    ContactsService,</div><div class="line">    &#123;</div><div class="line">      <span class="attr">provide</span>: <span class="string">'contact'</span>,</div><div class="line">      <span class="attr">useValue</span>: <span class="function">(<span class="params">route: ActivatedRouteSnapshot, state: RouterStateSnapshot</span>) =&gt;</span> &#123;</div><div class="line">        ...</div><div class="line">      &#125;</div><div class="line">  ]&#125;</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>이것은 <em>라우터 파라미터</em> 같이 우리가 접근이 필요한 곳에 접근할 수 있어, 유용하게 쓰일 수 있습니다.<br>하지만, 우리는 <code>ContactsService</code> 인스턴스도 필요합니다. 하지만 우리는 여기에 서비스를 주입할 수 없습니다. 그러면 <code>dependency injection</code>이 필요한 <code>resolver</code>는 어떻게 만들어야 할까요?</p>
<h3 id="Resolvers-with-dependencies"><a href="#Resolvers-with-dependencies" class="headerlink" title="Resolvers with dependencies"></a>Resolvers with dependencies</h3><p>이미 알다시피, <code>dependency injection</code>은 <code>class</code> 구조에서 작동합니다. 따라서 우린 <code>class</code>가 필요합니다. 다행히 우리는 <code>class</code>를 써서 <code>resolver</code>를 만들 수 있습니다. 우리가 해야하는 유일한 것은, <code>resolver</code> 클래스를 <code>Resolve</code> 인터페이스를 구현(implement)하고, <code>resolve()</code> 메소드를 추가하는 것입니다. 이 <code>resolve()</code> 메소드는 위에서 <code>DI</code>를 통해 등록한 것과 거의 같은 함수입니다.</p>
<p>아래는 클래스로 contact <code>resolver</code>를 구현한 것입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</div><div class="line"><span class="keyword">import</span> &#123; Resolve, ActivatedRouteSnapshot &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</div><div class="line"><span class="keyword">import</span> &#123; ContactsService &#125; <span class="keyword">from</span> <span class="string">'./contacts.service'</span>;</div><div class="line"></div><div class="line">@Injectable()</div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ContactResolve</span> <span class="title">implements</span> <span class="title">Resolve</span>&lt;<span class="title">Contact</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(private contactsService: ContactsService) &#123;&#125;</div><div class="line"></div><div class="line">  resolve(route: ActivatedRouteSnapshot) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.contactsService.getContact(route.params[<span class="string">'id'</span>]);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>resolver</code>가 클래스가 되면, 클래스는 <code>provider token</code>으로 사용될 수 있기 때문에 <code>provider</code> 구성은 매우 심플해집니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@NgModule(&#123;</div><div class="line">  ...</div><div class="line">  providers: [</div><div class="line">    ContactsService,</div><div class="line">    ContactResolve</div><div class="line">  ]</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>그리고 동일한 토큰을 route에 <code>resolver</code>로 사용하면 됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> AppRoutes: Routes = [</div><div class="line">  ...</div><div class="line">  &#123;</div><div class="line">    <span class="attr">path</span>: <span class="string">'contact/:id'</span>,</div><div class="line">    <span class="attr">component</span>: ContactsDetailComponent,</div><div class="line">    <span class="attr">resolve</span>: &#123;</div><div class="line">      <span class="attr">contact</span>: ContactResolve</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">];</div></pre></td></tr></table></figure>
<p>Angular는 <code>resolver</code>가 함수인지, 클래스인지, <code>resolve()</code>를 호출하는 클래스인지 탐지하기에 충분히 똑똑합니다.<br>어떻게 Angular가 데이터가 도착할때까지 컴포넌트를 인스턴스화 시키는 것을 지연시키는지(3초), 아래의 데모에서 확인해보세요.</p>
<iframe src="https://embed.plnkr.co/q8w7qf6aN5pzGw40GG0i/" frameborder="0" style="width:100%;height:500px;"></iframe>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/02/28/angular-resolve/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/02/24/observer/">
                            RxJS Observer
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-02-24T12:34:00+09:00">
	
		    2월 24, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/RxJS/">RxJS</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h3 id="이번에는-RxJS의-구성요소-중-observer에-대해서-알아보겠습니다"><a href="#이번에는-RxJS의-구성요소-중-observer에-대해서-알아보겠습니다" class="headerlink" title="이번에는 RxJS의 구성요소 중 observer에 대해서 알아보겠습니다."></a>이번에는 RxJS의 구성요소 중 observer에 대해서 알아보겠습니다.</h3><p><code>Observable</code>에 의해 전달 된 값을 처리하는 콜백 콜렉션입니다.<br><code>Observer</code>는 <code>Observable</code>에 의해 전달되는 특정한 알림에 대한  간단한 콜백함수 집합(<code>next</code>, <code>error</code>, and <code>complete</code>)입니다.</p>
<p>다음은 일반적인 <code>Observer</code> 객체의 예입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> observer = &#123;</div><div class="line">  <span class="attr">next</span>: <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Observer got a next value: '</span> + x),</div><div class="line">  <span class="attr">error</span>: <span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'Observer got an error: '</span> + err),</div><div class="line">  <span class="attr">complete</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Observer got a complete notification'</span>),</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>Observer</code>를 사용하기 위해서 <code>Observable</code>의 <code>subscribe</code>에게 <code>Observer</code>를 인자로 넘깁니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">observable.subscribe(observer);</div></pre></td></tr></table></figure>
<blockquote>
<p>Observer는 Observable이 전달하는 특정 알림에 대한 3개의 콜백을 가진 객체입니다.</p>
</blockquote>
<p>RxJS의 <code>Observer</code>는 불완전하게 쓰일 수 있습니다. 콜백 중 하나를 제공하지 않을경우, <code>Observable</code>에서 해당 콜백이 없기 때문에 일부 유형의 알림이 무시된다는 점을 제외하면 <code>Observable</code>의 실행은 계속 정상적으로 수행됩니다.</p>
<p>아래의 예제는 <code>observer</code>의 <code>complete</code>이 없는 케이스입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> observer = &#123;</div><div class="line">  <span class="attr">next</span>: <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Observer got a next value: '</span> + x),</div><div class="line">  <span class="attr">error</span>: <span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'Observer got an error: '</span> + err),</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>Observable</code>을 <code>subscribe</code>할 때, <code>Observer</code> 객체 대신 콜백을 <code>arguments</code>로 제공할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">observable.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Observer got a next value: '</span> + x));</div></pre></td></tr></table></figure>
<p><code>observable.subscribe</code>는 첫번째 콜백 <code>argument</code>를 사용해서 <code>Observer</code> 객체의 <code>next</code>핸들러를 만듭니다. 총 3개의 콜백 타입은 아래와 같이 쓸 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">observable.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Observer got a next value: '</span> + x),</div><div class="line">  err =&gt; <span class="built_in">console</span>.error(<span class="string">'Observer got an error: '</span> + err),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'Observer got a complete notification'</span>)</div><div class="line">);</div></pre></td></tr></table></figure>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/02/24/observer/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/02/21/rxjs-subject/">
                            RxJS Subject
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-02-21T12:34:00+09:00">
	
		    2월 21, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/RxJS/">RxJS</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p><em>이 글은 <a href="http://reactivex.io/rxjs/manual/overview.html#subject" target="_blank" rel="external">RxJS 공식사이트</a>의 내용 중 subject 영역을 번역한 글입니다.</em></p>
<p>RxJS Subject는 값을 많은 관찰자(Observer)에게 multicast 할 수 있게하는 특별한 유형의 Observable입니다. 일반 Observable은 unicast(각각의 subscribe된 Observer는 바라보고 있는 Observable을 독립적으로 실행함)이지만, Subject는 multicast입니다.</p>
<blockquote>
<p>Subject는 Observable과 비슷하지만 많은 Observers에게 멀티캐스트 할 수 있습니다. Subject는 EventEmitters와 유사합니다. 많은 수의 수신자(listeners)의 레지스트리를 관리합니다.</p>
</blockquote>
<p><strong>모든 Subject는 Observable입니다.</strong><br>Subject가 주어진다면 Observer를 구독(subscribe)하여 값을 정상적으로 받을 수 있습니다. Observer의 관점에서는, Observable 실행이 일반 unicast Observable에서 오는지, 또는 Subject에서 오는지를 알 수 없습니다.</p>
<p>내부적으로 Subject에서 subscribe는 값을 전달하는 새로운 실행을 호출하지 않습니다. addListener가 다른 라이브러리 및 언어에서 일반적으로 작동하는 것과 마찬가지로 Observer를 Observer 목록에 등록합니다.</p>
<p><strong>모든 Subject는 Observer입니다.</strong> Subject는 <code>next(v)</code>, <code>error(e)</code>, and <code>complete()</code> 메소드를 가진 객체입니다. Subject에 새 값을 공급하기위해 next를 호출하면 Subject를 수신하도록 등록 된 Observers로 멀티 캐스팅됩니다.</p>
<p>아래 예제에서는 Subject에 첨부 된 두 개의 Observer가 있으며, Subject에 값을 공급합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> subject = <span class="keyword">new</span> Rx.Subject();</div><div class="line"></div><div class="line">subject.subscribe(&#123;</div><div class="line">  <span class="attr">next</span>: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'observerA: '</span> + v)</div><div class="line">&#125;);</div><div class="line">subject.subscribe(&#123;</div><div class="line">  <span class="attr">next</span>: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'observerB: '</span> + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">subject.next(<span class="number">1</span>);</div><div class="line">subject.next(<span class="number">2</span>);</div></pre></td></tr></table></figure>
<p>콘솔을 보면…</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">observerA: <span class="number">1</span></div><div class="line">observerB: <span class="number">1</span></div><div class="line">observerA: <span class="number">2</span></div><div class="line">observerB: <span class="number">2</span></div></pre></td></tr></table></figure>
<p>Subject는 Observer이므로, 아래 예제와 같이 Observable 구독에 대한 인수로 Subject를 제공 할 수도 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> subject = <span class="keyword">new</span> Rx.Subject();</div><div class="line"></div><div class="line">subject.subscribe(&#123;</div><div class="line">  <span class="attr">next</span>: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'observerA: '</span> + v)</div><div class="line">&#125;);</div><div class="line">subject.subscribe(&#123;</div><div class="line">  <span class="attr">next</span>: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'observerB: '</span> + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> observable = Rx.Observable.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line">observable.subscribe(subject); <span class="comment">// You can subscribe providing a Subject</span></div><div class="line"></div><div class="line"><span class="comment">// observerA: 1</span></div><div class="line"><span class="comment">// observerB: 1</span></div><div class="line"><span class="comment">// observerA: 2</span></div><div class="line"><span class="comment">// observerB: 2</span></div><div class="line"><span class="comment">// observerA: 3</span></div><div class="line"><span class="comment">// observerB: 3</span></div></pre></td></tr></table></figure>
<p>위의 접근 방식으로, 우리는 Subject를 사용해서 unicast Observable 실행을 multicast로 변환했습니다. 이것은 Observable 실행을 여러 Observer들과 공유 할 수 있는 유일한 방법입니다.</p>
<p>Subject 유형에는 BehaviorSubject, ReplaySubject 및 AsyncSubject가 있습니다.</p>
<p><br><br></p>
<hr>
<h3 id="Multicasted-Observables"><a href="#Multicasted-Observables" class="headerlink" title="Multicasted Observables"></a>Multicasted Observables</h3><p>“multicasted Observable”은 다수의 subscriber를 가질 수 있는 Subject를 통해 통지를 전달하는 반면, “unicast Observable”은 단일 Observer에게만 통지를 보냅니다.</p>
<blockquote>
<p>multicasted Observable은 여러 Observers가 동일한 Observable 실행을 바라보도록 Subject를 사용합니다.</p>
</blockquote>
<p>아래는 멀티캐스트 연산자가 작동하는 방식입니다.<br>Observer들은 아래의 Subject을 구독(subscribe)하고 Subject는 Observable 소스를 구독합니다. 다음 예제는 <code>observable.subscribe(subject)</code>를 사용한 이전 예제와 유사합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> source = Rx.Observable.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line"><span class="keyword">var</span> subject = <span class="keyword">new</span> Rx.Subject();</div><div class="line"><span class="keyword">var</span> multicasted = source.multicast(subject);</div><div class="line"></div><div class="line"><span class="comment">// These are, under the hood, `subject.subscribe(&#123;...&#125;)`:</span></div><div class="line">multicasted.subscribe(&#123;</div><div class="line">  <span class="attr">next</span>: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'observerA: '</span> + v)</div><div class="line">&#125;);</div><div class="line">multicasted.subscribe(&#123;</div><div class="line">  <span class="attr">next</span>: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'observerB: '</span> + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// This is, under the hood, `source.subscribe(subject)`:</span></div><div class="line">multicasted.connect();</div></pre></td></tr></table></figure>
<p><code>multicast</code>는 평범한 Observable처럼 보이는 <code>Observable</code>을 반환하지만 구독(subscribe)할 때의 <code>Subject</code>와 같이 작동합니다.<br><code>multicast</code>는<code>connectableObservable</code>을 리턴합니다. 이것은 <code>connect()</code> 메소드를 가진 간단한 <code>Observable</code>입니다.</p>
<p><code>connect()</code> 메소드는 공유된 Observable 실행이 언제 시작될 것인지를 정확하게 결정합니다. <code>connect()</code>는 <code>source.subscribe(subject)</code>를 실행하기 때문에 <code>connect()</code>는 공유 <code>Observable</code>의 구독(subscribe)을 취소 할 수 있는 <code>Subscription</code>을 반환합니다.</p>
<h4 id="Reference-counting-참조-카운팅"><a href="#Reference-counting-참조-카운팅" class="headerlink" title="Reference counting(참조 카운팅)"></a>Reference counting(참조 카운팅)</h4><p><code>connect()</code>를 수동으로 호출하고 Subscription을 처리하는 것은 종종 번거로운 일입니다. 일반적으로 첫 <code>Observer</code>가 도착하면 자동으로 연결하고, 마지막 <code>Observer</code>가 구독을 취소하면 공유 실행을 자동으로 취소하려고합니다.</p>
<p>아래 목록에 설명 된대로 subscriptions이 발생하는 다음 예제를 살펴보겠습니다.</p>
<ol>
<li>첫번째 Observer가 multicasted Observable을 구독합니다.</li>
<li>Multicasted Observable가 연결됩니다.</li>
<li>다음 값 0이 첫번째 Observer에게 전달됩니다.</li>
<li>두번째 Observer가 multicasted Observable을 구독합니다.</li>
<li>다음 값 1이 첫번째 Observer에게 전달됩니다.</li>
<li>다음 값 1이 두번째 Observer에게 전달됩니다.</li>
<li>첫번째 Observer multicasted Observable 구독을 취소합니다.</li>
<li>다음 값 2이 두번째 Observer에게 전달됩니다.</li>
<li>두번째 Observer multicasted Observable 구독을 취소합니다.</li>
<li>Multicasted Observable 연결이 unsubscribe 되었습니다.</li>
</ol>
<p><code>connect()</code>를 명시적으로 호출하면 위 내용을 달성하기 위해 다음 코드를 작성합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">500</span>);</div><div class="line"><span class="keyword">var</span> subject = <span class="keyword">new</span> Rx.Subject();</div><div class="line"><span class="keyword">var</span> multicasted = source.multicast(subject);</div><div class="line"><span class="keyword">var</span> subscription1, subscription2, subscriptionConnect;</div><div class="line"></div><div class="line">subscription1 = multicasted.subscribe(&#123;</div><div class="line">  <span class="attr">next</span>: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'observerA: '</span> + v)</div><div class="line">&#125;);</div><div class="line"><span class="comment">// We should call `connect()` here, because the first</span></div><div class="line"><span class="comment">// subscriber to `multicasted` is interested in consuming values</span></div><div class="line">subscriptionConnect = multicasted.connect();</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  subscription2 = multicasted.subscribe(&#123;</div><div class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'observerB: '</span> + v)</div><div class="line">  &#125;);</div><div class="line">&#125;, <span class="number">600</span>);</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  subscription1.unsubscribe();</div><div class="line">&#125;, <span class="number">1200</span>);</div><div class="line"></div><div class="line"><span class="comment">// We should unsubscribe the shared Observable execution here,</span></div><div class="line"><span class="comment">// because `multicasted` would have no more subscribers after this</span></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  subscription2.unsubscribe();</div><div class="line">  subscriptionConnect.unsubscribe(); <span class="comment">// for the shared Observable execution</span></div><div class="line">&#125;, <span class="number">2000</span>);</div></pre></td></tr></table></figure>
<p><code>connect()</code>에 대한 명시적인 호출을 피하려면 <code>connectableObservable</code>의 <code>refCount()</code> 메서드(참조 카운팅)를 사용할 수 있습니다. 이 메서드는 <code>Observable</code>을 반환하며 <code>Observable</code>은 구독자 수를 추적합니다. 가입자 수가 0에서 1로 증가하면 <code>connect()</code>가 호출되어 공유 실행이 시작됩니다. 구독자 수가 1에서 0으로 줄어들 때만 완전히 구독 취소되어 더 이상 실행을 중지합니다.</p>
<blockquote>
<p><code>refCount</code>는 멀티캐스트 된 <code>Observable</code>에 첫 번째 subscriber가 도착하면 자동으로 실행을 시작하고 마지막 subscriber가 떠날 때 실행을 중지합니다.</p>
</blockquote>
<p>아래의 예제를 봅시다</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">500</span>);</div><div class="line"><span class="keyword">var</span> subject = <span class="keyword">new</span> Rx.Subject();</div><div class="line"><span class="keyword">var</span> refCounted = source.multicast(subject).refCount();</div><div class="line"><span class="keyword">var</span> subscription1, subscription2, subscriptionConnect;</div><div class="line"></div><div class="line"><span class="comment">// This calls `connect()`, because</span></div><div class="line"><span class="comment">// it is the first subscriber to `refCounted`</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'observerA subscribed'</span>);</div><div class="line">subscription1 = refCounted.subscribe(&#123;</div><div class="line">  <span class="attr">next</span>: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'observerA: '</span> + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'observerB subscribed'</span>);</div><div class="line">  subscription2 = refCounted.subscribe(&#123;</div><div class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'observerB: '</span> + v)</div><div class="line">  &#125;);</div><div class="line">&#125;, <span class="number">600</span>);</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'observerA unsubscribed'</span>);</div><div class="line">  subscription1.unsubscribe();</div><div class="line">&#125;, <span class="number">1200</span>);</div><div class="line"></div><div class="line"><span class="comment">// This is when the shared Observable execution will stop, because</span></div><div class="line"><span class="comment">// `refCounted` would have no more subscribers after this</span></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'observerB unsubscribed'</span>);</div><div class="line">  subscription2.unsubscribe();</div><div class="line">&#125;, <span class="number">2000</span>);</div><div class="line"></div><div class="line"><span class="comment">// observerA subscribed</span></div><div class="line"><span class="comment">// observerA: 0</span></div><div class="line"><span class="comment">// observerB subscribed</span></div><div class="line"><span class="comment">// observerA: 1</span></div><div class="line"><span class="comment">// observerB: 1</span></div><div class="line"><span class="comment">// observerA unsubscribed</span></div><div class="line"><span class="comment">// observerB: 2</span></div><div class="line"><span class="comment">// observerB unsubscribed</span></div></pre></td></tr></table></figure>
<p><code>refCount()</code> 메서드는 <code>ConnectableObservable</code>에만 존재하며 다른 <code>ConnectableObservable</code>이 아니라 <code>Observable</code>을 return합니다.</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/02/21/rxjs-subject/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">page 1 of 1</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2017 Owen. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <h4 id="about-card-name">Owen</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-close"></i></span>
            <a href="https://algolia.com" target="_blank" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    autofocus="autofocus"/>
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">no post found</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://owenjeon.github.io/2016/07/12/prototype/">
                            <h3 class="media-heading">객체 및 프로토타입</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 7월 12일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://owenjeon.github.io/2016/07/12/fill-image-css/">
                            <h3 class="media-heading">프레임에 이미지 꽉 채우기 Part2(css)</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 7월 12일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://owenjeon.github.io/2016/07/12/fill-image-javascript/">
                            <h3 class="media-heading">프레임에 이미지 꽉 채우기 Part2(Javascript)</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 7월 12일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://owenjeon.github.io/2016/08/10/prototype/">
                            <h3 class="media-heading">자바스크립트 프로토 타입의 프로퍼티 할당</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 8월 10일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://owenjeon.github.io/2016/08/12/array-object/">
                            <h3 class="media-heading">객체와 배열 구분하기</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 8월 12일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://owenjeon.github.io/2016/08/18/develop-patten/">
                            <h3 class="media-heading">다른 퍼블리셔들의 사용패턴 설문조사</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 8월 18일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://owenjeon.github.io/2016/08/21/valueof-tostring/">
                            <h3 class="media-heading">Javascript의 valueOf, toString</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 8월 21일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://owenjeon.github.io/2016/08/22/javascript-jsonp/">
                            <h3 class="media-heading">JSONP에 관하여...</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 8월 22일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://owenjeon.github.io/2016/08/28/javascript-reduce/">
                            <h3 class="media-heading">ECMA5 javascript method : reduce</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 8월 28일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://owenjeon.github.io/2016/09/01/javascript-map/">
                            <h3 class="media-heading">ECMA5 javascript method : map</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 9월 1일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="no post found"
                data-message-one="1 post found"
                data-message-other="{n} posts found">
                22 posts found
            </p>
        </div>
    </div>
</div>
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-keald3mnqximb0hm6mvdqo5sxhnyqoujkpxdeikbcx5yiukrhiboqm2jxh0x.min.js"></script>
<!--SCRIPTS END-->



    </body>
</html>
