
<!DOCTYPE html>
<html lang="ko">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Owen&#39;s Blog">
    <title>Tag: Angular - Owen&#39;s Blog</title>
    <meta name="author" content="Owen">
    
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <meta property="og:type" content="blog">
<meta property="og:title" content="Owen's Blog">
<meta property="og:url" content="https://owenjeon.github.io/tags/Angular/index.html">
<meta property="og:site_name" content="Owen's Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Owen's Blog">
    
    
        
    
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-gkdwv6gpmsvziyqj09onb2nm8pqnf9m6mfclab1sabtzip0qozttwf89jomo.min.css">
    <!--STYLES END-->
    
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">Owen&#39;s Blog</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/atom.xml"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/03/03/angular-dynamic-component/">
                            Angular2 Dynamic Component
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-03-03T12:34:00+09:00">
	
		    3월 03, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Angular/">Angular</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p>Angular로 애플리케이션을 제작하다보면 동적으로 컴포넌트를 추가해야할 때가 있습니다. 레이어 팝업을 띄운다던지, 페이지 내에서 사용자의 인터랙션에 따라 컨텐츠를 추가할 때, 우리는 특정 element를 생성해서 DOM에 추가하여야 합니다.</p>
<p>보통 Angular에서 컴포넌트의 추가는 <code>route</code>를 통해서만 이루어 집니다. 이때는 <code>route</code>에서 컴포넌트를 생성/제거를 해주기 때문에 우리는 크게 신경써야 할 부분이 없습니다.<br>하지만 동적으로 컴포넌트를 추가할때는 몇가지 신경써야 하는 부분들이 있습니다.</p>
<h2 id="template에-동적-컴포넌트를-추가할-영역-정하기"><a href="#template에-동적-컴포넌트를-추가할-영역-정하기" class="headerlink" title="template에 동적 컴포넌트를 추가할 영역 정하기."></a>template에 동적 컴포넌트를 추가할 영역 정하기.</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;Component, ViewChild&#125; <span class="keyword">from</span> <span class="string">"@angular/core"</span>;</div><div class="line">@Component(&#123;</div><div class="line">  <span class="attr">selector</span>: <span class="string">'home'</span>,</div><div class="line">  <span class="attr">template</span>: <span class="string">`</span></div><div class="line">    &lt;div #container&gt;&lt;/div&gt;</div><div class="line">  `</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>위는 컴포넌트 템플릿의 <code>#container</code>은 컴포넌트를 추가할 영역입니다. 그럼 이제 class에서 해당 영역을 선언해봅시다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeComponent</span></span>&#123;</div><div class="line">  @ViewChild(<span class="string">'container'</span>) container;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 <code>container</code>를 콘솔로 직어보면 <code>ElementRef</code>라는 객체가 보입니다. 이는 native 엘리먼트에 접근하기 위한 방법입니다.<br>하지만 우리는 <code>ViewContainerRef</code>가 필요합니다. 우리는 이를 다음과 같이 써서 얻을 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeComponent</span></span>&#123;</div><div class="line">  @ViewChild(<span class="string">'container'</span>, &#123;<span class="attr">read</span>:ViewContainerRef&#125;) container;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이렇게 하면, <code>container</code>를 <code>ElementRef</code>로 읽는 대신, <code>ViewContainerRef</code>로 읽어오게 됩니다.<br>다시 콘솔을 찍어보면 <code>ViewContainerRef</code> 객체가 보입니다. 이제 우리는 <code>this.container.createComponent</code>같은 메소드를 사용할 수 있습니다. 실제로 컴포넌트를 불러와 봅시다.</p>
<h2 id="동적으로-컴포넌트-생성하기"><a href="#동적으로-컴포넌트-생성하기" class="headerlink" title="동적으로 컴포넌트 생성하기"></a>동적으로 컴포넌트 생성하기</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeComponent</span></span>&#123;</div><div class="line">  @ViewChild(<span class="string">'container'</span>, &#123;<span class="attr">read</span>:ViewContainerRef&#125;) container;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(private resolver:ComponentFactoryResolver)&#123;&#125;</div><div class="line">  ngAfterContentInit()&#123;</div><div class="line">    <span class="keyword">this</span>.container.createComponent(<span class="keyword">this</span>.resolver.resolveComponentFactory(WidgetThree));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>CreateComponent</code>는 <code>ComponentFactory</code>를 사용합니다. 컴포넌트를 생성하려면 <code>CreateComponent</code>에 <code>ComponentFactory</code>를 전달해야합니다.<br><code>ComponentFactory Resolver</code>(<code>ComponentFactoryResolver</code>) 서비스를 삽입함으로써 컴포넌트 팩토리를 얻습니다. 이 Resolver를 사용하여 <code>this.resolver.resolveComponentFactory</code>를 호출 한 다음 유형별로 조회 할 수 있습니다.<br>그리고 <code>WidgetThree</code>라는 컴포넌트를 인자로 넘깁니다.</p>
<p>이를 좀 더 가독성 있게 바꿔보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ngAfterContentInit()&#123;</div><div class="line">  <span class="keyword">const</span> widgetFactory = <span class="keyword">this</span>.resolver.resolveComponentFactory(WidgetThree);</div><div class="line">  <span class="keyword">this</span>.container.createComponent(widgetFactory);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>widgetFactory</code> 변수에 <code>resolveComponentFactory(WidgetThree)</code>를 담았습니다. 그리고 이를 <code>createComponent</code>함수를 이용해서 <code>container</code>안에 컴포넌트를 추가하려고 합니다.</p>
<p>하지만 이 함수를 실행해보면 다음과 같은 에러가 납니다.</p>
<p><code>ORIGINAL EXCEPTION: No component factory found for WidgetThree</code></p>
<p>기본적으로 Angular와 Angular 컴파일러는 template들의 selector에 참조되지 않는 컴포넌트들은 컴파일 하지 않습니다. 즉, <code>selector</code>기반으로 찾고, 번들링 합니다. 그리고 나머지 컴포넌트들은 무시합니다.<br>따라서 우리가 만일 <code>WidgetThree</code>컴포넌트를 <code>module</code>에서 <code>declaration</code> 했다고 하더라도, <code>selector</code>에 지정되어 있지 않으면 번들링 되지 않는 것입니다.<br>따라서 이와같은 컴포넌트를 컴파일 대상에 강제로 배정하기 위해서는 <code>NgModule</code>의 옵션 <code>entryComponents</code>에 해당 컴포넌트를 추가해주어야 합니다. 이는 이 컴포넌트를 사용할 것이라고 정의하는 것입니다.</p>
<p>아래는 해당내용에 대한 코드입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@NgModule(&#123;</div><div class="line">  <span class="attr">imports</span>:[CommonModule],</div><div class="line">  <span class="attr">declarations</span>:[WidgetOne, WidgetTwo, WidgetThree],</div><div class="line">  <span class="attr">entryComponents</span>:[WidgetThree],</div><div class="line">  <span class="attr">exports</span>:[WidgetOne, WidgetTwo, WidgetThree, CommonModule]</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>자 이렇게 해서 실행하면 동적으로 컴포넌트를 추가 할 수 있습니다.</p>
<h2 id="동적으로-생성한-컴포넌트에-데이터-전달하기"><a href="#동적으로-생성한-컴포넌트에-데이터-전달하기" class="headerlink" title="동적으로 생성한 컴포넌트에 데이터 전달하기"></a>동적으로 생성한 컴포넌트에 데이터 전달하기</h2><p>생성한 컴포넌트의 <code>instance</code>객체를 이용하여 동적으로 생성한 컴포넌트에 데이터를 전달할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ngAfterViewInit()&#123;</div><div class="line">  <span class="keyword">const</span> widgetFactory = <span class="keyword">this</span>.resolver.resolveComponentFactory(WidgetThree);</div><div class="line">  <span class="keyword">const</span> widgetRef = <span class="keyword">this</span>.container.createComponent(widgetFactory);</div><div class="line">  widgetRef.instance.message = <span class="string">"I'm last!"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이제 데이터를 전달할 준비가 되었습니다. 받는쪽은 자식 컴포넌트가 부모 컴포넌트의 데이터를 받는 방식과 동일합니다. <code>WidgetThree</code>의 클래스에서 <code>@Input</code> 데코레이터를 사용하여 <code>message</code> 프로퍼티를 받습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Component(&#123;</div><div class="line">  <span class="attr">selector</span>: <span class="string">'widget-three'</span>,</div><div class="line">  <span class="attr">template</span>: <span class="string">`</span></div><div class="line">&lt;input #input type="text" [value]="message"&gt;</div><div class="line">`</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">WidgetThree</span></span>&#123;</div><div class="line">  @Input() message;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/03/03/angular-dynamic-component/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/03/02/angular-RouteReuseStrategy/">
                            Angular2 RouteReuseStrategy
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-03-02T12:34:00+09:00">
	
		    3월 02, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Angular/">Angular</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p>컨텐츠의 리스트와 뷰를 만들다 보면, 뷰에서 리스트로 돌아갔을 때 사용자가 탐색하던 위치를 다시 보여주는 것이 중요합니다. 특히 SPA의 경우, 페이지 이동이 하나의 DOM 요소안에서 이루어지기 때문에 이를 기억하고 찾아가기 쉽지 않습니다.</p>
<p>Angular도 마찬가지입니다. route를 써서 페이지 이동을 하다보면, <code>history.back()</code>으로 이전페이지로 돌아간다고 해도, 해당 위치를 찾을 수 없습니다.<br>route를 통해 뷰가 변경될 때, 지난 컴포넌트 인스턴스는 제거되기 때문입니다.</p>
<p>이런 문제는 Angular의 <code>RouteReuseStrategy</code>를 이용해서 해결 할 수 있습니다. <code>RouteReuseStrategy</code>는 route가 활성화 후 재사용 될때 커스터마이징 할 수 있는 방법을 제공합니다.<br><code>RouteReuseStrategy</code>는 route를 나중에 재사용 하기 위해서 <code>store</code>에 올려둘 수 있습니다. 즉 인스턴스를 삭제하지 않고 저장해 두었다가 다시 그 route가 호출 될 때 해당 인스턴스를 다시 가져와 보여줄 수 있습니다(싱글톤).</p>
<p><a href="https://angular.io/docs/ts/latest/api/router/index/RouteReuseStrategy-class.html" target="_blank" rel="external">구글 공식문서</a>에도 나와 있는 내용이지만 다시 정리해보면, <code>RouteReuseStrategy</code>는 다음과 같이 생겼습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RouteReuseStrategy</span> </span>&#123;</div><div class="line">  shouldDetach(route: ActivatedRouteSnapshot) : boolean</div><div class="line">  store(route: ActivatedRouteSnapshot, <span class="attr">handle</span>: DetachedRouteHandle) : <span class="keyword">void</span></div><div class="line">  shouldAttach(route: ActivatedRouteSnapshot) : boolean</div><div class="line">  retrieve(route: ActivatedRouteSnapshot) : DetachedRouteHandle</div><div class="line">  shouldReuseRoute(future: ActivatedRouteSnapshot, <span class="attr">curr</span>: ActivatedRouteSnapshot) : boolean</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>자세히 살펴보면 다음과 같은 메소드들로 구성되어 있습니다.</p>
<p><code>shouldDetach(route: ActivatedRouteSnapshot) : boolean</code><br><br>이 route (및 해당 하위 트리)를 나중에 store에 올려 재사용하기 위해 분리할지(detached) 여부를 결정합니다.</p>
<p><code>store(route: ActivatedRouteSnapshot, handle: DetachedRouteHandle) : void</code><br><br>분리 된 route를 저장합니다.</p>
<p><code>shouldAttach(route: ActivatedRouteSnapshot) : boolean</code><br><br>route를 호출할 때 (및 해당 하위 트리)를 store에 올려둔 것으로 연결할지 여부를 결정합니다.</p>
<p><code>retrieve(route: ActivatedRouteSnapshot) : DetachedRouteHandle</code><br><br>이전에 저장했던 route를 검색합니다.</p>
<p><code>shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot) : boolean</code><br><br>route를 다시 사용해야하는지 여부를 결정합니다.</p>
<p><strong>이 글은 추후 더 업데이트 될 예정입니다.</strong></p>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/03/02/angular-RouteReuseStrategy/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/02/28/angular-resolve/">
                            Angular2 Resolve
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-02-28T12:34:00+09:00">
	
		    2월 28, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Angular/">Angular</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p><strong>이 글은 <a href="https://blog.thoughtram.io/angular/2016/10/10/resolving-route-data-in-angular-2.html" target="_blank" rel="external">Thoughtram 블로그</a>를 참고하여 작성한 것입니다.</strong></p>
<p>Angular의 router를 이용하면 쉽게 페이지 전환을 할 수 있습니다. 하지만 좀 더 완벽히 구동되는 application을 만들기 위해서 router는 해결해야 할 문제점이 하나 있습니다. 바로 바인딩되는 데이터 로딩이 라우터가 실행보다 빠르게 완료되는 것이 보장되지 않는다는 것입니다. 예를들어 http통신을 통해 api로 특정 데이터를 가져오고, 이를 화면에 뿌린다고 했을때, http통신은 비동기이기 때문에 라우터가 먼저 실행되고 나서 얼마 후에 데이터 도착하면 view가 rendering 됩니다. 이 때문에 사용자들은 가끔 데이터가 듬성듬성 빠져있는 화면을 잠깐동안 보게 됩니다.</p>
<p>이를 해결하는 방법은 여러가지가 있습니다(데이터가 들어오기 전까지 host경로에 <code>ngIf</code>를 <code>false</code>로 한다는 등의…). 여기서는 <strong>Route의 resolver를</strong> 통해 문제를 해결해 보려고 합니다.</p>
<h3 id="무엇이-문제일까요"><a href="#무엇이-문제일까요" class="headerlink" title="무엇이 문제일까요?"></a>무엇이 문제일까요?</h3><p>자, contact 애플리케이션을 만들어 봅시다. 우리는 <code>contacts list</code>와 <code>contacts detail</code>을 위한 라우터를 가지고 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Routes &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</div><div class="line"><span class="keyword">import</span> &#123; ContactsListComponent &#125; <span class="keyword">from</span> <span class="string">'./contacts-list'</span>;</div><div class="line"><span class="keyword">import</span> &#123; ContactsDetailComponent &#125; <span class="keyword">from</span> <span class="string">'./contacts-detail'</span>;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> AppRoutes: Routes = [</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">''</span>, <span class="attr">component</span>: ContactsListComponent &#125;,</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'contact/:id'</span>, <span class="attr">component</span>: ContactsDetailComponent &#125;</div><div class="line">];</div></pre></td></tr></table></figure>
<p>그리고 당연히 우리는 해당 라우터를 탑재한 루트모듈이 필요합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</div><div class="line"><span class="keyword">import</span> &#123; BrowserModule &#125; <span class="keyword">from</span> <span class="string">'@angular/platform-browser'</span>;</div><div class="line"><span class="keyword">import</span> &#123; RouterModule &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</div><div class="line"><span class="keyword">import</span> &#123; AppRoutes &#125; <span class="keyword">from</span> <span class="string">'./app.routes'</span>;</div><div class="line"></div><div class="line">@NgModule(&#123;</div><div class="line">  <span class="attr">imports</span>: [</div><div class="line">    BrowserModule,</div><div class="line">    RouterModule.forRoot(AppRoutes)</div><div class="line">  ],</div><div class="line">  ...</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>여기까지 특별할 것은 없습니다. 만일 이 소스가 낯설다면 라우팅에 관한 <a href="https://angular.io/docs/ts/latest/tutorial/toh-pt5.html" target="_blank" rel="external">다른 글</a>을 먼저 읽으시는걸 권장합니다.</p>
<p><code>ContactsDetailComponent</code>을 살펴 봅시다. 이 컴포넌트는 contact data를 보여주는 역할을 가지고 있습니다. 따라서 route URL에서 제공되는 <code>id</code>값(route에서 <code>:id</code>로 포현되는 파라미터)을 가지고 <code>contact object</code>에 접근해야 합니다. <code>ActivatedRoute</code>를 통해서 쉽게 route parameter에 접근 할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</div><div class="line"><span class="keyword">import</span> &#123; ActivatedRoute &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</div><div class="line"><span class="keyword">import</span> &#123; ContactsService &#125; <span class="keyword">from</span> <span class="string">'../contacts.service'</span>;</div><div class="line"><span class="keyword">import</span> &#123; Contact &#125; <span class="keyword">from</span> <span class="string">'../interfaces/contact'</span>;</div><div class="line"></div><div class="line">@Component(&#123;</div><div class="line">  <span class="attr">selector</span>: <span class="string">'contacts-detail'</span>,</div><div class="line">  <span class="attr">template</span>: <span class="string">'...'</span></div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ContactsDetailComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</div><div class="line"></div><div class="line">  contact: Contact;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(</div><div class="line">    private contactsService: ContactsService,</div><div class="line">    private route: ActivatedRoute</div><div class="line">  ) &#123;&#125;</div><div class="line"></div><div class="line">  ngOnInit() &#123;</div><div class="line">    <span class="keyword">let</span> id = <span class="keyword">this</span>.route.snapshot.params[<span class="string">'id'</span>];</div><div class="line">    <span class="keyword">this</span>.contactsService.getContact(id)</div><div class="line">        .subscribe(<span class="function"><span class="params">contact</span> =&gt;</span> <span class="keyword">this</span>.contact = contact);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>좋습니다. <code>ContactsDetailComponent</code>는 받은 <code>id</code>를 가지고 <code>contact</code> 객체를 가져오고, 로컬 <code>contact</code> property에 제공합니다. 그리고 `{{contact.name}}`같은 표현을 통해 컴포넌트의 템플릿에 값을 삽입합니다.<br>컴포넌트의 템플릿을 살펴봅시다!</p>

undefined


<p><code>contact</code>객체 뒤에 물음표(?)를 붙였습니다. 이를 Safe Navigation Operators(SNO)라고 부릅니다. 이는 만일 비동기로 <code>contact</code> 데이터를 바인딩한다면, 컴포넌트가 초기화될때 <code>contact</code>는 <code>undefined</code>이기 때문에, 프로퍼티를 가질 수 없어 에러를 내는 것을 방지하기 위한 표현입니다.<br>이 이슈를 구현하기 위해서, <code>ContactsService#getContact()</code>에 3초 딜레이를 주고 <code>contact</code> 오브젝트를 내보내겠습니다. <code>RxJS</code>의 <code>delay</code> 오퍼레이터를 쓰면 쉽게 구현할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</div><div class="line"></div><div class="line">@Injectable()</div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ContactsService</span> </span>&#123;</div><div class="line"></div><div class="line">  getContact(id) &#123;</div><div class="line">    <span class="keyword">return</span> Observable.of(&#123;</div><div class="line">      <span class="attr">id</span>: id,</div><div class="line">      <span class="attr">name</span>: <span class="string">'Pascal Precht'</span>,</div><div class="line">      <span class="attr">website</span>: <span class="string">'http://thoughtram.io'</span>,</div><div class="line">    &#125;).delay(<span class="number">3000</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>템플릿 마다 SNO를 모든 곳에 추가하는 것도 상당히 힘든 일이 될 수 있습니다. 그 외에도 <code>NgModel</code> 및 <code>RouterLink</code> Directive와 같은 일부 연산자는 SNO를 지원하지 않습니다. 이제 <code>route resolver</code>를 사용하여 어떻게 해결할 수 있는지 살펴 보겠습니다.</p>
<h3 id="resolver의-정의"><a href="#resolver의-정의" class="headerlink" title="resolver의 정의"></a>resolver의 정의</h3><p><code>route resolvers</code>는 route가 활성화 되기전에, route에게 필요한 데이터를 제공하는 것을 도와줍니다. <code>resolver</code>를 생성하는 것은 여러 방법이 있습니다. 우리는 가장 쉬운것 부터 시작할 것입니다. <code>resolver</code>는 <code>Observable&lt;any&gt;</code>, <code>Promise&lt;any&gt;</code> 또는 단지 데이터를 반환하는 함수입니다.</p>
<p>Resolver는 Angular Module의 <code>providers</code>에 등록되어야 합니다.</p>
<p>여기에 static한 <code>contact</code> object를 반환하는 resolver 함수가 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@NgModule(&#123;</div><div class="line">  ...</div><div class="line">  providers: [</div><div class="line">    ContactsService,</div><div class="line">    &#123;</div><div class="line">      <span class="attr">provide</span>: <span class="string">'contact'</span>,</div><div class="line">      <span class="attr">useValue</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">          <span class="attr">id</span>: <span class="number">1</span>,</div><div class="line">          <span class="attr">name</span>: <span class="string">'Some Contact'</span>,</div><div class="line">          <span class="attr">website</span>: <span class="string">'http://some.website.com'</span></div><div class="line">        &#125;;</div><div class="line">      &#125;</div><div class="line">  ]&#125;</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>우리는 <code>resolver</code>가 사용될때 항상 같은 <code>contact</code> object가 반환되는걸 바라지 않습니다. 우리는 Angular의 <code>dependency injection(DI, 의존성 주입)</code>를 사용해서 간단한 <code>resolver</code> 함수를 등록할 수 있습니다. 어떻게 이 <code>resolver</code>를 <code>route</code>에 연결하면 될까요? resolve 프로퍼티를 <code>resolver</code>를 사용할 route 구성안에 추가하면 됩니다.</p>
<p>아래는 어떻게 우리의 <code>resolver</code> 함수를 <code>route</code> 구성에 추가하는지 보여줍니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> AppRoutes: Routes = [</div><div class="line">  ...</div><div class="line">  &#123;</div><div class="line">    <span class="attr">path</span>: <span class="string">'contact/:id'</span>,</div><div class="line">    <span class="attr">component</span>: ContactsDetailComponent,</div><div class="line">    <span class="attr">resolve</span>: &#123;</div><div class="line">      <span class="attr">contact</span>: <span class="string">'contact'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">];</div></pre></td></tr></table></figure>
<p>이게 다인가요? 네 맞습니다! <code>&#39;contact&#39;</code>는 <code>resolver</code>를 route 구성에 추가할때에 참고하는 <code>provider</code> 토큰입니다.</p>
<p>이제 우리가해야 할 일은 <code>ContactsDetailComponent</code>가 <code>contact</code> 객체를 유지하는 방법을 변경하는 것입니다. <strong>route resolvers를</strong> 통해 전달되는 모든 것은 <code>ActivatedRoute</code>의 데이터 속성에 노출됩니다. 즉, 이제 우리는 다음과 같이 <code>ContactsService</code> 종속성(dependency)을 제거 할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@Component()</div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ContactsDetailComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</div><div class="line"></div><div class="line">  contact;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(private route: ActivatedRoute) &#123;&#125;</div><div class="line"></div><div class="line">  ngOnInit() &#123;</div><div class="line">    <span class="keyword">this</span>.contact = <span class="keyword">this</span>.route.snapshot.data[<span class="string">'contact'</span>];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>사실, resolver함수를 정의하면, 우리는 <code>RouterStateSnapshot</code>뿐 아니라 <code>ActivatedRouteSnapshot</code>에도 접근할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@NgModule(&#123;</div><div class="line">  ...</div><div class="line">  providers: [</div><div class="line">    ContactsService,</div><div class="line">    &#123;</div><div class="line">      <span class="attr">provide</span>: <span class="string">'contact'</span>,</div><div class="line">      <span class="attr">useValue</span>: <span class="function">(<span class="params">route: ActivatedRouteSnapshot, state: RouterStateSnapshot</span>) =&gt;</span> &#123;</div><div class="line">        ...</div><div class="line">      &#125;</div><div class="line">  ]&#125;</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>이것은 <em>라우터 파라미터</em> 같이 우리가 접근이 필요한 곳에 접근할 수 있어, 유용하게 쓰일 수 있습니다.<br>하지만, 우리는 <code>ContactsService</code> 인스턴스도 필요합니다. 하지만 우리는 여기에 서비스를 주입할 수 없습니다. 그러면 <code>dependency injection</code>이 필요한 <code>resolver</code>는 어떻게 만들어야 할까요?</p>
<h3 id="Resolvers-with-dependencies"><a href="#Resolvers-with-dependencies" class="headerlink" title="Resolvers with dependencies"></a>Resolvers with dependencies</h3><p>이미 알다시피, <code>dependency injection</code>은 <code>class</code> 구조에서 작동합니다. 따라서 우린 <code>class</code>가 필요합니다. 다행히 우리는 <code>class</code>를 써서 <code>resolver</code>를 만들 수 있습니다. 우리가 해야하는 유일한 것은, <code>resolver</code> 클래스를 <code>Resolve</code> 인터페이스를 구현(implement)하고, <code>resolve()</code> 메소드를 추가하는 것입니다. 이 <code>resolve()</code> 메소드는 위에서 <code>DI</code>를 통해 등록한 것과 거의 같은 함수입니다.</p>
<p>아래는 클래스로 contact <code>resolver</code>를 구현한 것입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</div><div class="line"><span class="keyword">import</span> &#123; Resolve, ActivatedRouteSnapshot &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</div><div class="line"><span class="keyword">import</span> &#123; ContactsService &#125; <span class="keyword">from</span> <span class="string">'./contacts.service'</span>;</div><div class="line"></div><div class="line">@Injectable()</div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ContactResolve</span> <span class="title">implements</span> <span class="title">Resolve</span>&lt;<span class="title">Contact</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(private contactsService: ContactsService) &#123;&#125;</div><div class="line"></div><div class="line">  resolve(route: ActivatedRouteSnapshot) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.contactsService.getContact(route.params[<span class="string">'id'</span>]);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>resolver</code>가 클래스가 되면, 클래스는 <code>provider token</code>으로 사용될 수 있기 때문에 <code>provider</code> 구성은 매우 심플해집니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@NgModule(&#123;</div><div class="line">  ...</div><div class="line">  providers: [</div><div class="line">    ContactsService,</div><div class="line">    ContactResolve</div><div class="line">  ]</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>그리고 동일한 토큰을 route에 <code>resolver</code>로 사용하면 됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> AppRoutes: Routes = [</div><div class="line">  ...</div><div class="line">  &#123;</div><div class="line">    <span class="attr">path</span>: <span class="string">'contact/:id'</span>,</div><div class="line">    <span class="attr">component</span>: ContactsDetailComponent,</div><div class="line">    <span class="attr">resolve</span>: &#123;</div><div class="line">      <span class="attr">contact</span>: ContactResolve</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">];</div></pre></td></tr></table></figure>
<p>Angular는 <code>resolver</code>가 함수인지, 클래스인지, <code>resolve()</code>를 호출하는 클래스인지 탐지하기에 충분히 똑똑합니다.<br>어떻게 Angular가 데이터가 도착할때까지 컴포넌트를 인스턴스화 시키는 것을 지연시키는지(3초), 아래의 데모에서 확인해보세요.</p>
<iframe src="https://embed.plnkr.co/q8w7qf6aN5pzGw40GG0i/" frameborder="0" style="width:100%;height:500px;"></iframe>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/02/28/angular-resolve/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/01/27/angular-detection/">
                            Angular2의 변화 탐지(Change Detection)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-01-27T22:34:00+09:00">
	
		    1월 27, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Angular/">Angular</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p><strong>이 글은 <a href="https://blog.thoughtram.io/angular/2016/02/22/angular-2-change-detection-explained.html" target="_blank" rel="external">Thoughtram 블로그</a>의 글을 번역한 것입니다. 번역이 미흡하더라도 너그럽게 이해해주세요.</strong></p>
<p>만일 이 이야기에 흥미가 있다면, 이 <a href="https://pascalprecht.github.io/slides/angular-2-change-detection-explained/#/" target="_blank" rel="external">슬라이드</a>를 보거나 <a href="https://www.youtube.com/watch?v=CUxD91DWkGM" target="_blank" rel="external">유튜브 비디오</a>를 봐도 됩니다.</p>
<h3 id="What’s-Change-Detection-anyways"><a href="#What’s-Change-Detection-anyways" class="headerlink" title="What’s Change Detection anyways?"></a>What’s Change Detection anyways?</h3><p>변화 감지(change detection)의 기본적인 태스크는 프로그램 내부의 상태(stats)를 가져와서 그것을 사용자 인터페이스에 구현하는 것입니다. 이 상태는 objects, arrays, primitives등 모든 종류의 자바스크립트 데이터 구조일 것입니다.</p>
<p>이 stats는 사용자 인터페이스나 DOM 웹사이트의 특정부분의 paragraphs, forms, 링크 또는 버튼 에서 보여질 것입니다. 따라서 기본적으로 우리는 데이터 구조를 입력받아 DOM 출력을 생성하여 사용자가 화면에서 볼 수 있도록 만듭니다. 우리는 이 프로세스를 rendering이라고 부르죠.</p>
<p><img src="/assets/images/angular/cd-4.svg" alt="" style="background-color:#0c4eb2"></p>
<p>하지만, 그것이 런타임에 변경이 발생하거나, DOM이 이미 랜더링된 얼마 후 일 경우에 처리가 까다로워집니다. Model에서 무엇이 바뀌 었는지, 그리고 DOM을 어디에서 업데이트해야하는지 어떻게 알 수 있을까요? DOM 트리에 액세스하는 것은 항상 비용이 많이 들기 때문에 업데이트가 필요한 위치를 알아야 하고, 액세스를 가능한 한 작게 유지해야 합니다.</p>
<p>이 이슈는 여러 가지 방법으로 해결할 수 있습니다. 한 가지 방법은 단순히 HTTP 요청을 하고 전체 페이지를 다시 렌더링하는 것입니다. 또 다른 접근법은 새로운 상태의 DOM을 이전 상태와 구분하여 차이점 만 렌더링하는 것입니다. ReactJS가 가상 DOM을 사용하여 수행하는 것처럼..</p>
<p>이와 관련해서 Tero는 <a href="http://teropa.info/blog/2015/03/02/change-and-its-detection-in-javascript-frameworks.html" target="_blank" rel="external">Change and its detection in JavaScript frameworks</a>라는 훌륭한 글을 썼습니다. 만일 당신이 프레임워크들이 어떻게 이 이슈를 해결하는지 좀 더 흥미가 있다면 이 글을 읽어보기를 추천합니다. 본 글에서는 Angular2 이상 버전에 대해서만 집중합니다.</p>
<p>기본적으로 변경 감지의 목표는 항상 데이터와 그 변화를 투영(projecting)하는 것입니다.</p>
<h3 id="무엇이-변화를-일으키는가"><a href="#무엇이-변화를-일으키는가" class="headerlink" title="무엇이 변화를 일으키는가?"></a>무엇이 변화를 일으키는가?</h3><p>자, 이제 우리는 변화 탐지가 무엇인지 알게되었으므로 정확히 언제 그러한 변화가 일어날 수 있는지 알아보겠습니다. Angular는 View를 업데이트 해야한다는 것을 언제 알 수 있을까요?<br>
undefined

</p>
<p>앵귤러 component를 처음 보는 경우 탭 <a href="https://blog.thoughtram.io/angular/2015/04/09/developing-a-tabs-component-in-angular-2.html" target="_blank" rel="external">component 작성에 대한 도움말</a>을 읽는 것이 좋습니다.</p>
<p>위의 component는 두 개의 속성(property)을 표시하고 템플릿의 button을 클릭 할 때 변경하는 메서드를 제공합니다. 이 특정 단추를 클릭하는 순간 application 상태(state)가 변경되면 component의 속성이 변경되기 때문입니다. 그 순간에 우리는 view를 업데이트하려고 합니다.</p>
<p>여기에 다른 코드가 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@Component()</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContactsApp</span> <span class="title">implements</span> <span class="title">OnInit</span></span>&#123;</div><div class="line"></div><div class="line">  contacts:Contact[] = [];</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(private http: Http) &#123;&#125;</div><div class="line"></div><div class="line">  ngOnInit() &#123;</div><div class="line">    <span class="keyword">this</span>.http.get(<span class="string">'/contacts'</span>)</div><div class="line">      .map(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</div><div class="line">      .subscribe(<span class="function"><span class="params">contacts</span> =&gt;</span> <span class="keyword">this</span>.contacts = contacts);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 component는 컨텐츠 목록을 가지고 있고, 그것이 초기화 되었을때 http 요청을 수행합니다. 이 요청이 다시 들어 오면 목록이 업데이트됩니다. 다시, 이 시점에서 application 상태가 변경되었으므로 view를 업데이트하려고 합니다.</p>
<p>기본적으로 application 상태 변화는 3가지에 의해 발생됩니다.</p>
<ul>
<li><strong>Events</strong> - click, submit, …</li>
<li><strong>XHR</strong> - 원격 데이터로부터 데이터를 가져오는 것</li>
<li><strong>Timers</strong> - <code>setTimeout()</code>, <code>setInterval()</code></li>
</ul>
<p>이것들은 모두 비동기입니다. 따라서 기본적으로 일부 비동기 작업이 수행 될 때마다 application 상태가 변경될 수 있다는 결론을 얻습니다. 이것은 누군가가 Angular에게 view를 업데이트 하라고 말해 줄 필요가 있을 때입니다.</p>
<h3 id="Angular에게-알리는-것은-무엇일까요"><a href="#Angular에게-알리는-것은-무엇일까요" class="headerlink" title="Angular에게 알리는 것은 무엇일까요?"></a>Angular에게 알리는 것은 무엇일까요?</h3><p>자, 이제 응용 프로그램 상태 변경의 원인을 알았습니다. 그러나 이 특정 순간에 view가 업데이트되어야 한다고 Angular에게 알리는 것은 무엇일까요?</p>
<p>Angular는 우리에게 native API(web의 경우 addEventListener 같은…)를 직접 사용하는 것을 허용합니다. Angular가 DOM을 업데이트 하는 알림을 받기 위해서, 우리가 호출 해야만하는 어떠한 가로채는(interceptor) methods도 없습니다. 이것은 마술일까요?</p>
<p>만일 최신 버젼의 글을 읽었다면, 당신은 이것을 처리하는 Zones을 알것입니다. 실제로, Angular는 <code>NgZone</code>이라는 자체 영역(zone)을 제공합니다. 우리는 <a href="https://blog.thoughtram.io/angular/2016/02/01/zones-in-angular-2.html" target="_blank" rel="external">Zones in Angular</a>라는 글을 기록 했었습니다.</p>
<p>Angular 소스 코드에서 <code>NgZones</code>, <code>onTurnDone</code> 이벤트를 수신하는 <code>ApplicationRef</code>라는 것이 있습니다. 이 이벤트가 발생하면, 본질적으로 변경 검출을 실시하는 <code>tick()</code> 함수를 실행합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 실제 Angular 코드의 매우 짧은 버젼</span></div><div class="line"><span class="keyword">class</span> ApplicationRef &#123;</div><div class="line"></div><div class="line">  changeDetectorRefs:ChangeDetectorRef[] = [];</div><div class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> zone: NgZone</span>) &#123;</div><div class="line">    <span class="keyword">this</span>.zone.onTurnDone.subscribe(() =&gt; <span class="keyword">this</span>.zone.run(() =&gt; <span class="keyword">this</span>.tick());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  tick() &#123;</div><div class="line">    <span class="keyword">this</span>.changeDetectorRefs</div><div class="line">      .forEach((ref) =&gt; ref.detectChanges());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Change-Detection"><a href="#Change-Detection" class="headerlink" title="Change Detection"></a>Change Detection</h3><p>좋습니다. 이제 변경 감지가 트리거되는 시점을 알 수 있지만 어떻게 수행될까요? Angular에서는 각 component마다 고유 한 변경 감지기가 있습니다.</p>
<p><img src="/assets/images/angular/cd-tree-2.svg" alt="" style="background-color:#0c4eb2"></p>
<p>이는 중요한 사실입니다. 이는 각 component에 대해 변경 감지가 수행되는 방법과시기를 개별적으로 제어 할 수 있기 때문입니다!</p>
<p>component 트리의 어딘가에 이벤트가 발생했다고 가정 해 봅시다. 버튼이 클릭되었을 수도 있습니다. 다음에 어떻게 될까요? 영역이 주어진 핸들러를 실행하고 턴이 완료되면 Angular에 알리고, 결국 Angular가 변경 감지를 수행한다는 것을 알았습니다.</p>
<p><img src="/assets/images/angular/cd-tree-7.svg" alt="" style="background-color:#0c4eb2"></p>
<p>각 component에는 고유 한 변경 감지기가 있고, Angular application은 component 트리로 구성되므로 결론적으로 변경 감지기 트리도 있다는 것입니다. 이 트리는 데이터가 항상 위에서 아래로 흐르는 방향 그래프로 볼 수도 있습니다.</p>
<p>데이터가 위에서 아래로 흐르는 이유는 root component부터 모든 단일 component에 대해 항상 변경 감지가 항상 위에서 아래로 수행되기 때문입니다. 단방향 데이터 흐름이 주기(cycles)보다 예측 가능하기 때문에 매우 좋습니다. 우리는 뷰에서 사용하는 데이터의 출처를 항상 알고 있습니다. 이는 해당 component에서만 발생할 수 있기 때문입니다.</p>
<p>또 다른 흥미로운 점은 변경 감지가 단일 패스(single pass) 후에 안정화된다는 것입니다. 즉, component 중 하나가 변경 감지 중에 첫 번째 실행 후 추가적인 부작용이 발생하면 Angular는 오류를 발생시킵니다.</p>
<h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><p>기본적으로 이벤트가 발생할 때마다 모든 단일 component를 검사해야 하더라도 Angular는 매우 빠릅니다. 몇 milliseconds 내에 수십만 개의 점검을 수행 할 수 있습니다. 이것은 Angular가 VM 친화적인 코드(VM friendly code)를 생성하기 때문에 가능합니다.</p>
<p>무슨 뜻일까요? 각 component마다 고유 한 변경 감지기가 있다는 것은, 각 개별 component의 변경 감지를 처리하는 Angular의 하나의 포괄적인 처리기(generic thing)가 있다는 것과 같은 의미가 아닙니다.</p>
<p>그 이유는 변경 감지기가 동적 방식으로 작성되어야 하기 때문에 모델 구조가 어떻든간에 모든 component를 확인할 수 있기 때문입니다. VM은 최적화 할 수 없다는 이유로 이런 종류의 동적 코드를 좋아하지 않습니다. 객체의 모양이 항상 동일하지는 않기 때문에 다형성(polymorphic)으로 간주됩니다.</p>
<p>Angular는 component 모델의 모양이 무엇인지 정확하게 알고 있기 때문에, 단일 component인 각 component의 런타임에 변경 감지기 클래스를 만듭니다. VM은이 코드를 완벽하게 최적화 할 수 있으므로 실행 속도가 매우 빠릅니다. 좋은 점은 Angular가 자동으로 처리하므로 너무 많이 신경 쓰지 않아도 된다는 것입니다.</p>
<h3 id="Smarter-Change-Detection"><a href="#Smarter-Change-Detection" class="headerlink" title="Smarter Change Detection"></a>Smarter Change Detection</h3><p>다시 말하지만, Angular는 이벤트가 발생할 때마다 모든 component를 확인해야합니다. 애플리케이션 상태가 변경되었을 수 있기 때문입니다. 그러나 Angular가 상태를 변경 한 application의 부분에 대해서만 변경 감지를 실행하도록 말할 수 있다면 좋지 않을까요?</p>
<p>그렇습니다. 할 수 있습니다! 무언가가 바뀌 었는지 여부에 대한 보장을 제공하는 데이터 구조(data structures)가 있습니다.</p>
<ul>
<li><strong>Immutables and Observables</strong> 이러한 structure 나 type을 사용하게되면 Angular에 알려줌으로써 변경 감지가 훨씬 더 빠를 수 있습니다. 그럼 어떻게 해야 할까요?</li>
</ul>
<h4 id="Understanding-Mutability"><a href="#Understanding-Mutability" class="headerlink" title="Understanding Mutability"></a>Understanding Mutability</h4><p>이유 및 방법을 이해하기 위해 불변의 데이터 구조(immutable data structures)가 도움이된다면, 우리는 변경 가능성(mutability)의 의미를 이해할 필요가 있습니다. 다음과 같은 component가 있다고 가정합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@Component(&#123;</div><div class="line">  <span class="attr">template</span>: <span class="string">'&lt;v-card [vData]="vData"&gt;&lt;/v-card&gt;'</span></div><div class="line">&#125;)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">VCardApp</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.vData = &#123;</div><div class="line">      <span class="attr">name</span>: <span class="string">'Christoph Burgdorf'</span>,</div><div class="line">      <span class="attr">email</span>: <span class="string">'christoph@thoughtram.io'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  changeData() &#123;</div><div class="line">    <span class="keyword">this</span>.vData.name = <span class="string">'Pascal Precht'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>VCardApp</code>는 <code>&lt;v-card&gt;</code>를 하위 component로 사용하며 이 component에는 <code>vData</code> 입력 속성이 있습니다. <code>VCardApp</code>의 <code>vData</code> 속성을 사용하여 해당 component로 데이터를 전달합니다. <code>vData</code>는 두 가지 속성을 가진 객체입니다. 또한 <code>vData</code>의 이름을 변경하는 <code>changeData()</code> 메서드가 있습니다. 여기에 별다른 신기한 점은 없습니다.</p>
<p>중요한 부분은 <code>changeData()</code>가 <code>name</code> 속성을 변경하여 <code>vData</code>를 변경한다는 점입니다. 해당 속성이 변경 되더라도 <code>vData</code> 참조 자체는 그대로 유지됩니다.</p>
<p>어떤 이벤트로 인해 <code>changeData()</code>가 실행된다고 가정하고, 변경 감지가 수행 될 때 어떤 일이 발생할까요? 먼저 <code>vData.name</code>이 변경된 다음 <code>&lt;v-card&gt;</code>로 전달됩니다. <code>&lt;v-card&gt;</code>의 변경 감지기는 이제 <code>vData</code>가 이전과 여전히 동일한지 확인합니다. 참조(reference)는 변경되지 않았습니다. 그러나 <code>name</code> 속성이 변경되었으므로 Angular는 해당 객체에 대한 변경 감지를 수행합니다.</p>
<p>자바 스크립트에서는 객체가 기본적으로 변경 가능하기 때문에 (프리미티브(primitives) 제외) Angular는 보수적이어야하며 이벤트가 발생할 때마다 모든 component에 대해 변경 감지를 실행해야합니다.</p>
<p>다음은 불변의(immutable) 데이터 구조가 작동하는 곳입니다.</p>
<h3 id="Immutable-Objects"><a href="#Immutable-Objects" class="headerlink" title="Immutable Objects"></a>Immutable Objects</h3><p>변경할 수 없는 객체는 객체 불변을 보장해 줍니다. 즉, 불변 객체를 사용하고 그러한 객체를 변경하고자 할 때, 원래 객체가 변경되지 않기 때문에 우리는 항상 그 변경으로 새로운 참조를 얻습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> vData = someAPIForImmutables.create(&#123;</div><div class="line">              <span class="attr">name</span>: <span class="string">'Pascal Precht'</span></div><div class="line">            &#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> vData2 = vData.set(<span class="string">'name'</span>, <span class="string">'Christoph Burgdorf'</span>);</div><div class="line"></div><div class="line">vData === vData2 <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p><code>someAPIForImmutables</code>는 변경 불가능한 데이터 구조에 사용하려는 모든 API가 될 수 있습니다. 그러나 예제에서 볼 수 있듯이 단순히 name 속성을 변경할 수는 없습니다. 우리는 그 특별한 변화를 가진 새로운 객체를 얻게 될 것이고 이 객체는 새로운 참조를 가지고 있습니다.</p>
<h3 id="점검-횟수-줄이기-Reducing-the-number-of-checks"><a href="#점검-횟수-줄이기-Reducing-the-number-of-checks" class="headerlink" title="점검 횟수 줄이기(Reducing the number of checks)"></a>점검 횟수 줄이기(Reducing the number of checks)</h3><p>Angular는 입력 속성이 변경되지 않을 때 전체 변경 감지 하위 트리를 건너 뛸 수 있습니다. 우리는 방금 “변화”가 “새로운 참조”를 의미한다는 것을 배웠습니다. Angular 앱에서 불변 객체를 사용하는 경우, 입력 값이 변경되지 않은 경우 component가 변경 감지를 건너 뛸 수 있다고 Angular에 알려주면됩니다.</p>
<p><code>&lt;v-card&gt;</code>를 통해 어떻게 작동하는지 봅시다.<br>
undefined

<br>보시다시피, <code>VCardCmp</code>는 입력 속성에만 의존합니다. 좋습니다. 변경 감지 전략을 다음과 같이 <code>OnPush</code>로 설정하여 입력이 변경되지 않으면 이 component의 하위 트리에 대한 변경 감지를 건너 뛰도록 Angular에 지시 할 수 있습니다.<br>
undefined

<br>이게 전부입니다! 이제 더 큰 component 트리를 상상해보십시오. 불변 객체를 사용하고, Angular에 적절하게 정보가 전달되면 전체 하위 트리를 건너 뛸 수 있습니다.</p>
<p><img src="/assets/images/angular/cd-tree-8.svg" alt="" style="background-color:#0c4eb2"></p>
<h3 id="Observables"><a href="#Observables" class="headerlink" title="Observables"></a>Observables</h3><p>이전에 언급 한 바와 같이 Observables는 변경 사항이 언제 발생했는지 확실하게 보장합니다. 불변 객체와는 달리, 변경 사항이있을 때 새로운 참조(references)를 제공하지 않습니다.<br>대신, Observables은 그들에게 반응하기 위해 우리가 구독 할 수 있는 이벤트를 제공합니다.</p>
<p>만일 우리가 Observables을 사용하고, 우리가 변경 감지 하위트리를 건너뛰기 위해서 <code>OnPush</code>를 사용하기를 원한다 할 때, 이러한 객체의 참조가 변경되지 않으면 어떻게 처리해야 할까요? Angular는 component 트리의 경로에서 특정 이벤트를 검사 할 수 있는 매우 현명한 방법을 제공합니다.</p>
<p>이것이 의미하는 것을 이해하기 위해 아래의 component를 살펴 보겠습니다.<br>
undefined

</p>
<p>장바구니가있는 e-commerce 애플리케이션을 구축한다고 가정 해 보겠습니다. 사용자가 장바구니에 제품을 올릴 때마다 우리는 UI에 작은 카운터를 표시하여 카트의 제품 수량을 볼 수 있습니다.</p>
<p><code>CartBadgeCmp</code>의 역할이 그것입니다. 제품에는 장바구니에 제품이 추가 될 때마다 실행되는 이벤트 스트림 인 <code>counter</code> 와 입력 속성 <code>addItemStream</code>이 있습니다.</p>
<p>우리는 이 글에서 observables이 어떻게 작동하는지에 대해 자세히 설명하지 않을 것입니다. observables에 대해 더 자세히 알고 싶다면 <a href="http://blog.thoughtram.io/angular/2016/01/06/taking-advantage-of-observables-in-angular2.html" target="_blank" rel="external">Observables in Angular를 활용하는 방법에 대한 글</a>를 읽어보세요.</p>
<p>또한 변경 검색 전략을 <code>OnPush</code>로 설정하므로, 오직 component의 입력 속성이 변경될 때만 변경 감지가 수행됩니다.</p>
<p>그러나 앞에서 언급했듯이 <code>addItemStream</code>의 참조는 변경되지 않으므로 이 component의 하위 트리에 대한 변경 감지가 수행되지 않습니다. component가 <code>ngOnInit</code> 라이프 사이클 hook에서 해당 스트림을 subscribe하고 카운터를 증가시키기 때문에 이는 문제가됩니다. 이것은 응용 프로그램 상태 변경이며 이를 반영하고 싶습니다.</p>
<p>변경 탐지기 트리가 어떻게 생겼는지 (모든 것을 OnPush로 설정했습니다) 이벤트가 발생하면 변경 감지가 수행되지 않습니다.</p>
<p><img src="/assets/images/angular/cd-tree-10.svg" alt="" style="background-color:#0c4eb2"></p>
<p>이 변화에 대해 Angular에게 어떻게 알릴 수 있습니까? 전체 트리가 OnPush로 설정된 경우에도이 component에 대해 변경 감지를 수행해야한다는 Angular를 어떻게 알 수 있습니까?</p>
<p>걱정 마세요. Angular는 우리에게 적용됩니다. 앞서 학습 한 것처럼 변경 감지는 항상 위에서 아래로 수행됩니다. 따라서 우리는 변경이 발생한 component에 대한 트리의 전체 경로에 대한 변경을 감지하는 방법이 필요합니다. Angular는 어느 경로인지 알 수 없지만 우리는 알수 있습니다.</p>
<p>우리는 <code>markForCheck()</code>라는 API와 함께 제공되는 의존성 삽입을 통해 컴포넌트의 <code>ChangeDetectorRef</code>에 액세스 할 수 있습니다. 이 방법은 우리가 필요로하는 것을 정확히 수행합니다! 다음 변경 감지 실행을 위해 루트까지 component의 경로를 표시합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constructor</span>(private cd: ChangeDetectorRef) &#123;&#125;</div></pre></td></tr></table></figure>
<p>그런 다음 Angular에 이 component의 경로를 확인할 루트까지 표시하도록 지시합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">  ngOnInit() &#123;</div><div class="line">    <span class="keyword">this</span>.addItemStream.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">this</span>.counter++; <span class="comment">// application state changed</span></div><div class="line">      <span class="keyword">this</span>.cd.markForCheck(); <span class="comment">// marks path</span></div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>다됐습니다! observable 이벤트가 시작된 후, 변경 감지 시작 전의 모습은 다음과 같습니다.</p>
<p><img src="/assets/images/angular/cd-tree-12.svg" alt="" style="background-color:#0c4eb2"></p>
<p>이제 변경 감지가 수행되면 단순히 위에서 아래로 이동합니다.</p>
<p><img src="/assets/images/angular/cd-tree-13.svg" alt="" style="background-color:#0c4eb2"></p>
<p>멋지죠? 변경 감지 실행이 끝나면 전체 트리의 <code>OnPush</code> 상태를 복원합니다.</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/01/27/angular-detection/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">page 1 of 1</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2017 Owen. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <h4 id="about-card-name">Owen</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-close"></i></span>
            <a href="https://algolia.com" target="_blank" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    autofocus="autofocus"/>
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">no post found</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://owenjeon.github.io/2016/07/12/prototype/">
                            <h3 class="media-heading">객체 및 프로토타입</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 7월 12일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://owenjeon.github.io/2016/07/12/fill-image-css/">
                            <h3 class="media-heading">프레임에 이미지 꽉 채우기 Part2(css)</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 7월 12일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://owenjeon.github.io/2016/07/12/fill-image-javascript/">
                            <h3 class="media-heading">프레임에 이미지 꽉 채우기 Part2(Javascript)</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 7월 12일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://owenjeon.github.io/2016/08/10/prototype/">
                            <h3 class="media-heading">자바스크립트 프로토 타입의 프로퍼티 할당</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 8월 10일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://owenjeon.github.io/2016/08/12/array-object/">
                            <h3 class="media-heading">객체와 배열 구분하기</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 8월 12일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://owenjeon.github.io/2016/08/18/develop-patten/">
                            <h3 class="media-heading">다른 퍼블리셔들의 사용패턴 설문조사</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 8월 18일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://owenjeon.github.io/2016/08/21/valueof-tostring/">
                            <h3 class="media-heading">Javascript의 valueOf, toString</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 8월 21일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://owenjeon.github.io/2016/08/22/javascript-jsonp/">
                            <h3 class="media-heading">JSONP에 관하여...</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 8월 22일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://owenjeon.github.io/2016/08/28/javascript-reduce/">
                            <h3 class="media-heading">ECMA5 javascript method : reduce</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 8월 28일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://owenjeon.github.io/2016/09/01/javascript-map/">
                            <h3 class="media-heading">ECMA5 javascript method : map</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 9월 1일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="no post found"
                data-message-one="1 post found"
                data-message-other="{n} posts found">
                22 posts found
            </p>
        </div>
    </div>
</div>
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-keald3mnqximb0hm6mvdqo5sxhnyqoujkpxdeikbcx5yiukrhiboqm2jxh0x.min.js"></script>
<!--SCRIPTS END-->



    </body>
</html>
