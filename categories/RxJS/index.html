
<!DOCTYPE html>
<html lang="ko">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Owen&#39;s Blog">
    <title>Category: RxJS - Owen&#39;s Blog</title>
    <meta name="author" content="Owen">
    
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <meta property="og:type" content="blog">
<meta property="og:title" content="Owen's Blog">
<meta property="og:url" content="https://owenjeon.github.io/categories/RxJS/index.html">
<meta property="og:site_name" content="Owen's Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Owen's Blog">
    
    
        
    
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-gkdwv6gpmsvziyqj09onb2nm8pqnf9m6mfclab1sabtzip0qozttwf89jomo.min.css">
    <!--STYLES END-->
    
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">Owen&#39;s Blog</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/atom.xml"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/02/24/observer/">
                            RxJS Observer
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-02-24T12:34:00+09:00">
	
		    2월 24, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/RxJS/">RxJS</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h3 id="이번에는-RxJS의-구성요소-중-observer에-대해서-알아보겠습니다"><a href="#이번에는-RxJS의-구성요소-중-observer에-대해서-알아보겠습니다" class="headerlink" title="이번에는 RxJS의 구성요소 중 observer에 대해서 알아보겠습니다."></a>이번에는 RxJS의 구성요소 중 observer에 대해서 알아보겠습니다.</h3><p><code>Observable</code>에 의해 전달 된 값을 처리하는 콜백 콜렉션입니다.<br><code>Observer</code>는 <code>Observable</code>에 의해 전달되는 특정한 알림에 대한  간단한 콜백함수 집합(<code>next</code>, <code>error</code>, and <code>complete</code>)입니다.</p>
<p>다음은 일반적인 <code>Observer</code> 객체의 예입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> observer = &#123;</div><div class="line">  <span class="attr">next</span>: <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Observer got a next value: '</span> + x),</div><div class="line">  <span class="attr">error</span>: <span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'Observer got an error: '</span> + err),</div><div class="line">  <span class="attr">complete</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Observer got a complete notification'</span>),</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>Observer</code>를 사용하기 위해서 <code>Observable</code>의 <code>subscribe</code>에게 <code>Observer</code>를 인자로 넘깁니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">observable.subscribe(observer);</div></pre></td></tr></table></figure>
<blockquote>
<p>Observer는 Observable이 전달하는 특정 알림에 대한 3개의 콜백을 가진 객체입니다.</p>
</blockquote>
<p>RxJS의 <code>Observer</code>는 불완전하게 쓰일 수 있습니다. 콜백 중 하나를 제공하지 않을경우, <code>Observable</code>에서 해당 콜백이 없기 때문에 일부 유형의 알림이 무시된다는 점을 제외하면 <code>Observable</code>의 실행은 계속 정상적으로 수행됩니다.</p>
<p>아래의 예제는 <code>observer</code>의 <code>complete</code>이 없는 케이스입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> observer = &#123;</div><div class="line">  <span class="attr">next</span>: <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Observer got a next value: '</span> + x),</div><div class="line">  <span class="attr">error</span>: <span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'Observer got an error: '</span> + err),</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>Observable</code>을 <code>subscribe</code>할 때, <code>Observer</code> 객체 대신 콜백을 <code>arguments</code>로 제공할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">observable.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Observer got a next value: '</span> + x));</div></pre></td></tr></table></figure>
<p><code>observable.subscribe</code>는 첫번째 콜백 <code>argument</code>를 사용해서 <code>Observer</code> 객체의 <code>next</code>핸들러를 만듭니다. 총 3개의 콜백 타입은 아래와 같이 쓸 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">observable.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Observer got a next value: '</span> + x),</div><div class="line">  err =&gt; <span class="built_in">console</span>.error(<span class="string">'Observer got an error: '</span> + err),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'Observer got a complete notification'</span>)</div><div class="line">);</div></pre></td></tr></table></figure>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/02/24/observer/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/02/21/rxjs-subject/">
                            RxJS Subject
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-02-21T12:34:00+09:00">
	
		    2월 21, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/RxJS/">RxJS</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p><em>이 글은 <a href="http://reactivex.io/rxjs/manual/overview.html#subject" target="_blank" rel="external">RxJS 공식사이트</a>의 내용 중 subject 영역을 번역한 글입니다.</em></p>
<p>RxJS Subject는 값을 많은 관찰자(Observer)에게 multicast 할 수 있게하는 특별한 유형의 Observable입니다. 일반 Observable은 unicast(각각의 subscribe된 Observer는 바라보고 있는 Observable을 독립적으로 실행함)이지만, Subject는 multicast입니다.</p>
<blockquote>
<p>Subject는 Observable과 비슷하지만 많은 Observers에게 멀티캐스트 할 수 있습니다. Subject는 EventEmitters와 유사합니다. 많은 수의 수신자(listeners)의 레지스트리를 관리합니다.</p>
</blockquote>
<p><strong>모든 Subject는 Observable입니다.</strong><br>Subject가 주어진다면 Observer를 구독(subscribe)하여 값을 정상적으로 받을 수 있습니다. Observer의 관점에서는, Observable 실행이 일반 unicast Observable에서 오는지, 또는 Subject에서 오는지를 알 수 없습니다.</p>
<p>내부적으로 Subject에서 subscribe는 값을 전달하는 새로운 실행을 호출하지 않습니다. addListener가 다른 라이브러리 및 언어에서 일반적으로 작동하는 것과 마찬가지로 Observer를 Observer 목록에 등록합니다.</p>
<p><strong>모든 Subject는 Observer입니다.</strong> Subject는 <code>next(v)</code>, <code>error(e)</code>, and <code>complete()</code> 메소드를 가진 객체입니다. Subject에 새 값을 공급하기위해 next를 호출하면 Subject를 수신하도록 등록 된 Observers로 멀티 캐스팅됩니다.</p>
<p>아래 예제에서는 Subject에 첨부 된 두 개의 Observer가 있으며, Subject에 값을 공급합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> subject = <span class="keyword">new</span> Rx.Subject();</div><div class="line"></div><div class="line">subject.subscribe(&#123;</div><div class="line">  <span class="attr">next</span>: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'observerA: '</span> + v)</div><div class="line">&#125;);</div><div class="line">subject.subscribe(&#123;</div><div class="line">  <span class="attr">next</span>: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'observerB: '</span> + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">subject.next(<span class="number">1</span>);</div><div class="line">subject.next(<span class="number">2</span>);</div></pre></td></tr></table></figure>
<p>콘솔을 보면…</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">observerA: <span class="number">1</span></div><div class="line">observerB: <span class="number">1</span></div><div class="line">observerA: <span class="number">2</span></div><div class="line">observerB: <span class="number">2</span></div></pre></td></tr></table></figure>
<p>Subject는 Observer이므로, 아래 예제와 같이 Observable 구독에 대한 인수로 Subject를 제공 할 수도 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> subject = <span class="keyword">new</span> Rx.Subject();</div><div class="line"></div><div class="line">subject.subscribe(&#123;</div><div class="line">  <span class="attr">next</span>: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'observerA: '</span> + v)</div><div class="line">&#125;);</div><div class="line">subject.subscribe(&#123;</div><div class="line">  <span class="attr">next</span>: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'observerB: '</span> + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> observable = Rx.Observable.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line">observable.subscribe(subject); <span class="comment">// You can subscribe providing a Subject</span></div><div class="line"></div><div class="line"><span class="comment">// observerA: 1</span></div><div class="line"><span class="comment">// observerB: 1</span></div><div class="line"><span class="comment">// observerA: 2</span></div><div class="line"><span class="comment">// observerB: 2</span></div><div class="line"><span class="comment">// observerA: 3</span></div><div class="line"><span class="comment">// observerB: 3</span></div></pre></td></tr></table></figure>
<p>위의 접근 방식으로, 우리는 Subject를 사용해서 unicast Observable 실행을 multicast로 변환했습니다. 이것은 Observable 실행을 여러 Observer들과 공유 할 수 있는 유일한 방법입니다.</p>
<p>Subject 유형에는 BehaviorSubject, ReplaySubject 및 AsyncSubject가 있습니다.</p>
<p><br><br></p>
<hr>
<h3 id="Multicasted-Observables"><a href="#Multicasted-Observables" class="headerlink" title="Multicasted Observables"></a>Multicasted Observables</h3><p>“multicasted Observable”은 다수의 subscriber를 가질 수 있는 Subject를 통해 통지를 전달하는 반면, “unicast Observable”은 단일 Observer에게만 통지를 보냅니다.</p>
<blockquote>
<p>multicasted Observable은 여러 Observers가 동일한 Observable 실행을 바라보도록 Subject를 사용합니다.</p>
</blockquote>
<p>아래는 멀티캐스트 연산자가 작동하는 방식입니다.<br>Observer들은 아래의 Subject을 구독(subscribe)하고 Subject는 Observable 소스를 구독합니다. 다음 예제는 <code>observable.subscribe(subject)</code>를 사용한 이전 예제와 유사합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> source = Rx.Observable.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line"><span class="keyword">var</span> subject = <span class="keyword">new</span> Rx.Subject();</div><div class="line"><span class="keyword">var</span> multicasted = source.multicast(subject);</div><div class="line"></div><div class="line"><span class="comment">// These are, under the hood, `subject.subscribe(&#123;...&#125;)`:</span></div><div class="line">multicasted.subscribe(&#123;</div><div class="line">  <span class="attr">next</span>: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'observerA: '</span> + v)</div><div class="line">&#125;);</div><div class="line">multicasted.subscribe(&#123;</div><div class="line">  <span class="attr">next</span>: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'observerB: '</span> + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// This is, under the hood, `source.subscribe(subject)`:</span></div><div class="line">multicasted.connect();</div></pre></td></tr></table></figure>
<p><code>multicast</code>는 평범한 Observable처럼 보이는 <code>Observable</code>을 반환하지만 구독(subscribe)할 때의 <code>Subject</code>와 같이 작동합니다.<br><code>multicast</code>는<code>connectableObservable</code>을 리턴합니다. 이것은 <code>connect()</code> 메소드를 가진 간단한 <code>Observable</code>입니다.</p>
<p><code>connect()</code> 메소드는 공유된 Observable 실행이 언제 시작될 것인지를 정확하게 결정합니다. <code>connect()</code>는 <code>source.subscribe(subject)</code>를 실행하기 때문에 <code>connect()</code>는 공유 <code>Observable</code>의 구독(subscribe)을 취소 할 수 있는 <code>Subscription</code>을 반환합니다.</p>
<h4 id="Reference-counting-참조-카운팅"><a href="#Reference-counting-참조-카운팅" class="headerlink" title="Reference counting(참조 카운팅)"></a>Reference counting(참조 카운팅)</h4><p><code>connect()</code>를 수동으로 호출하고 Subscription을 처리하는 것은 종종 번거로운 일입니다. 일반적으로 첫 <code>Observer</code>가 도착하면 자동으로 연결하고, 마지막 <code>Observer</code>가 구독을 취소하면 공유 실행을 자동으로 취소하려고합니다.</p>
<p>아래 목록에 설명 된대로 subscriptions이 발생하는 다음 예제를 살펴보겠습니다.</p>
<ol>
<li>첫번째 Observer가 multicasted Observable을 구독합니다.</li>
<li>Multicasted Observable가 연결됩니다.</li>
<li>다음 값 0이 첫번째 Observer에게 전달됩니다.</li>
<li>두번째 Observer가 multicasted Observable을 구독합니다.</li>
<li>다음 값 1이 첫번째 Observer에게 전달됩니다.</li>
<li>다음 값 1이 두번째 Observer에게 전달됩니다.</li>
<li>첫번째 Observer multicasted Observable 구독을 취소합니다.</li>
<li>다음 값 2이 두번째 Observer에게 전달됩니다.</li>
<li>두번째 Observer multicasted Observable 구독을 취소합니다.</li>
<li>Multicasted Observable 연결이 unsubscribe 되었습니다.</li>
</ol>
<p><code>connect()</code>를 명시적으로 호출하면 위 내용을 달성하기 위해 다음 코드를 작성합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">500</span>);</div><div class="line"><span class="keyword">var</span> subject = <span class="keyword">new</span> Rx.Subject();</div><div class="line"><span class="keyword">var</span> multicasted = source.multicast(subject);</div><div class="line"><span class="keyword">var</span> subscription1, subscription2, subscriptionConnect;</div><div class="line"></div><div class="line">subscription1 = multicasted.subscribe(&#123;</div><div class="line">  <span class="attr">next</span>: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'observerA: '</span> + v)</div><div class="line">&#125;);</div><div class="line"><span class="comment">// We should call `connect()` here, because the first</span></div><div class="line"><span class="comment">// subscriber to `multicasted` is interested in consuming values</span></div><div class="line">subscriptionConnect = multicasted.connect();</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  subscription2 = multicasted.subscribe(&#123;</div><div class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'observerB: '</span> + v)</div><div class="line">  &#125;);</div><div class="line">&#125;, <span class="number">600</span>);</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  subscription1.unsubscribe();</div><div class="line">&#125;, <span class="number">1200</span>);</div><div class="line"></div><div class="line"><span class="comment">// We should unsubscribe the shared Observable execution here,</span></div><div class="line"><span class="comment">// because `multicasted` would have no more subscribers after this</span></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  subscription2.unsubscribe();</div><div class="line">  subscriptionConnect.unsubscribe(); <span class="comment">// for the shared Observable execution</span></div><div class="line">&#125;, <span class="number">2000</span>);</div></pre></td></tr></table></figure>
<p><code>connect()</code>에 대한 명시적인 호출을 피하려면 <code>connectableObservable</code>의 <code>refCount()</code> 메서드(참조 카운팅)를 사용할 수 있습니다. 이 메서드는 <code>Observable</code>을 반환하며 <code>Observable</code>은 구독자 수를 추적합니다. 가입자 수가 0에서 1로 증가하면 <code>connect()</code>가 호출되어 공유 실행이 시작됩니다. 구독자 수가 1에서 0으로 줄어들 때만 완전히 구독 취소되어 더 이상 실행을 중지합니다.</p>
<blockquote>
<p><code>refCount</code>는 멀티캐스트 된 <code>Observable</code>에 첫 번째 subscriber가 도착하면 자동으로 실행을 시작하고 마지막 subscriber가 떠날 때 실행을 중지합니다.</p>
</blockquote>
<p>아래의 예제를 봅시다</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">500</span>);</div><div class="line"><span class="keyword">var</span> subject = <span class="keyword">new</span> Rx.Subject();</div><div class="line"><span class="keyword">var</span> refCounted = source.multicast(subject).refCount();</div><div class="line"><span class="keyword">var</span> subscription1, subscription2, subscriptionConnect;</div><div class="line"></div><div class="line"><span class="comment">// This calls `connect()`, because</span></div><div class="line"><span class="comment">// it is the first subscriber to `refCounted`</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'observerA subscribed'</span>);</div><div class="line">subscription1 = refCounted.subscribe(&#123;</div><div class="line">  <span class="attr">next</span>: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'observerA: '</span> + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'observerB subscribed'</span>);</div><div class="line">  subscription2 = refCounted.subscribe(&#123;</div><div class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'observerB: '</span> + v)</div><div class="line">  &#125;);</div><div class="line">&#125;, <span class="number">600</span>);</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'observerA unsubscribed'</span>);</div><div class="line">  subscription1.unsubscribe();</div><div class="line">&#125;, <span class="number">1200</span>);</div><div class="line"></div><div class="line"><span class="comment">// This is when the shared Observable execution will stop, because</span></div><div class="line"><span class="comment">// `refCounted` would have no more subscribers after this</span></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'observerB unsubscribed'</span>);</div><div class="line">  subscription2.unsubscribe();</div><div class="line">&#125;, <span class="number">2000</span>);</div><div class="line"></div><div class="line"><span class="comment">// observerA subscribed</span></div><div class="line"><span class="comment">// observerA: 0</span></div><div class="line"><span class="comment">// observerB subscribed</span></div><div class="line"><span class="comment">// observerA: 1</span></div><div class="line"><span class="comment">// observerB: 1</span></div><div class="line"><span class="comment">// observerA unsubscribed</span></div><div class="line"><span class="comment">// observerB: 2</span></div><div class="line"><span class="comment">// observerB unsubscribed</span></div></pre></td></tr></table></figure>
<p><code>refCount()</code> 메서드는 <code>ConnectableObservable</code>에만 존재하며 다른 <code>ConnectableObservable</code>이 아니라 <code>Observable</code>을 return합니다.</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/02/21/rxjs-subject/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/01/01/rxjs-trans-operator/">
                            RxJS Transformation Operator
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-01-01T16:34:43+09:00">
	
		    1월 01, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/RxJS/">RxJS</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h3 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h3><p>buffer는 말그대로 Obervable의 실행을 일정기간 미루는 것이다. 시리즈 성격의 buffer Operators는 몇가지가 있는데, 이들 모두 공통적으로 Obervable의 실행을 일정기간 미룬다.</p>
<h4 id="buffer-1"><a href="#buffer-1" class="headerlink" title="buffer"></a>buffer</h4><p>Obervable을 인자로 받으며, 인자의 Obervable이 subscribe될 때 미루고 있던 이전의 Obervable의 subscribe값들을 배열로 반환한다.  </p>
<p>아래 예재에서는 document 클릭할때마다 1초마다 쌓인 스트림을 배열로 반환 한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obBuffer = Rx.Observable.interval(<span class="number">1000</span>)</div><div class="line">  .buffer(Rx.Observable.fromEvent(<span class="built_in">document</span>,<span class="string">'click'</span>));</div><div class="line">obBuffer.subscribe(<span class="function"><span class="params">x</span>=&gt;</span><span class="built_in">console</span>.log(x));</div></pre></td></tr></table></figure></p>
<h4 id="bufferCount"><a href="#bufferCount" class="headerlink" title="bufferCount"></a>bufferCount</h4><p>bufferCount는 두개의 인자를 받는다. 첫 번째는 도출되는 buffer의 최대 사이즈가 오며, 두 번째는 새로운 buffer가 몇번의 스트림을 주기로 실행될것인지가 온다. 즉 bufferCount(3,2)라면 여기서 도출되는 스트림은, input Observable의 스트림중 최근 3개를 인자로 묶은 배열이 2번의 주기로 실행되는 것이다.(말이 어렵다… ㅠ)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obBufferCount = Rx.Observable.interval(<span class="number">1000</span>)</div><div class="line">  .bufferCount(<span class="number">3</span>, <span class="number">4</span>);</div><div class="line">obBufferCount.subscribe(<span class="function"><span class="params">x</span>=&gt;</span><span class="built_in">console</span>.log(x)); <span class="comment">//[0,1,2], [4,5,6] ...</span></div></pre></td></tr></table></figure>
<h4 id="bufferTime"><a href="#bufferTime" class="headerlink" title="bufferTime"></a>bufferTime</h4><p>Observable 값을 특정 시간단위로 지연시켜 배출한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obBufferTime = Rx.Observable.interval(<span class="number">1000</span>).bufferTime(<span class="number">3000</span>);</div><div class="line">obBufferTime.subscribe(<span class="function"><span class="params">x</span>=&gt;</span><span class="built_in">console</span>.log(x)); <span class="comment">//[0, 1], [2,3,4], [5,6,7]</span></div></pre></td></tr></table></figure></p>
<h4 id="bufferToggle"><a href="#bufferToggle" class="headerlink" title="bufferToggle"></a>bufferToggle</h4><p>bufferToggle은 두개의 인자를 받는다. 첫 번째는 buffer를 시작하는, 두 번째는 buffer를 마무리 하기 위한 인자가 온다. 첫 번째는 구독가능하거나 Promise로 반환되는(Subscribable Or Promise) 값이오고, 두 번째는 구독가능하거나 Promise로 반환되는(Subscribable Or Promise) 값을 도출하는 함수가 온다. 결국 두개의 Observable을 인자로 받아 시작점과 끝나는 지점을 정하고 이 안에 있는 스트림을 배열로 묶어 배출한다. 만일 promise라면 resolve함수가 실행되는 시점이 시작하거나 마무리하는 시점이 되며, 이는 시점을 정할뿐 인자를 넘겨 줄 수 없다(아마도….)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obBufferToggle = Rx.Observable.interval(<span class="number">1000</span>) <span class="comment">//1초에 1씩 증가하는 값을 반환하는 스트림</span></div><div class="line">  .bufferToggle(Rx.Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'click'</span>), (e)=&gt;&#123; <span class="comment">//시작 시점은 문서를 클릭할때</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">res, rej</span>)</span>&#123;</div><div class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span>&#123;</div><div class="line">        res(<span class="number">100</span>)<span class="comment">//인자는 쓰이지 않는다...?</span></div><div class="line">      &#125;, <span class="number">2000</span>)</div><div class="line">    &#125;)<span class="comment">//끝나는 시점은 2초가 지난 후.</span></div><div class="line">  &#125;);</div><div class="line">obBufferToggle.subscribe(<span class="function"><span class="params">x</span>=&gt;</span><span class="built_in">console</span>.log(x)); <span class="comment">//[n, n+1], [m, m+1]...</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><h4 id="map-1"><a href="#map-1" class="headerlink" title="map"></a>map</h4><p><a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-map" target="_blank" rel="external">map</a>은 Array method들 중에 가장 많이 쓰이는 것 중에 하나이다. RxJS의 맵도 거의 같은 역할을 한다. 차이점이라면 Array method는 배열의 인자를 순회하면서 콜백 함수에 의한 값을 리턴하는 반면, RxJS의 map은 스트림 값을 받아 콜백함수에 의한 값을 그대로 흘려보내준다는 것이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obMap = Rx.Observable.from([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</div><div class="line">  .map(<span class="function"><span class="params">x</span> =&gt;</span> x+<span class="number">10</span>);</div><div class="line">obMap.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x)); <span class="comment">// 11, 12, 13, 14</span></div></pre></td></tr></table></figure></p>
<h4 id="mapTo"><a href="#mapTo" class="headerlink" title="mapTo"></a>mapTo</h4><p><a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-mapTo" target="_blank" rel="external">mapTo</a>는 map과 거의 유사하다. 하지만 아웃풋 값이 mapTo의 인자 값으로 고정이다. 다음에 나오는 operator들에도 뒤에 to가 붙는 것들이 있는데, 대부분 기본 operator 기능에 인자 값을 subscribe로 넘기는 비슷한 역할을 한다.  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obMapTo = Rx.subscribe.from([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</div><div class="line">  .mapTo(<span class="string">'10'</span>);</div><div class="line">obMapTo.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x)); <span class="comment">//10, 10, 10, 10</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="concatMap-exhaustMap-mergeMap-switchMap"><a href="#concatMap-exhaustMap-mergeMap-switchMap" class="headerlink" title="concatMap exhaustMap mergeMap switchMap"></a>concatMap exhaustMap mergeMap switchMap</h3><p>이 Operator들은 인자로 Observable을 받는다. 그리고 인풋의 Observable과 인자의 Observable을 합쳐(flat) 하나의 스트림을 반환한다. 두 번째 인자로는 콜백함수를 포함시킬 수 있다. 인자로는 총 4개를 받는데, <code>Outer Observable의 값</code>, <code>Inner Observable의 값</code>, <code>Outer Observable의 Index</code>, <code>Inner Observable의 Index</code>로 구성된다. 각각은 다음과 같은 특징을 가지고 있다.</p>
<ul>
<li><code>concat</code> Observable이 끝나면 이어서 다음 Observable을 실행. 첫 번째 Observable이 끝나기 에 두 번째 Observable이 실행해도 첫 번째 Observable이 끝나고 나서 두 번째가 실행된다.</li>
<li><code>exhaust</code> Observable이 실행되고 있을때 실행되는 다음 Observable을 무시한다.</li>
<li><code>merge</code> Observable이 발생하는대로 모두 실행한다. (<code>flatMap</code>과 동일한 것으로 보인다.)</li>
<li><code>switch</code> Observable이 실행되고 있을때 다음 Observable이 실행되면 먼저실행된 Observable을 중단시킨다.</li>
</ul>
<p>모든 Operator가 비슷하게 작동하므로 소스예제는 하나만 기록한다. 중간에 Operator만 바꾸면 작동한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> clicks = Rx.Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'click'</span>);</div><div class="line"><span class="keyword">const</span> higherOrder = clicks.concatMap(<span class="function"><span class="params">ev</span> =&gt;</span> Rx.Observable.interval(<span class="number">1000</span>).take(<span class="number">3</span>), (i,j,k,l) =&gt; &#123;</div><div class="line">  <span class="keyword">return</span> [i,j,k,l];</div><div class="line">&#125;);</div><div class="line">higherOrder.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</div></pre></td></tr></table></figure>
<hr>
<h3 id="window"><a href="#window" class="headerlink" title="window"></a>window</h3><p><a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-window" target="_blank" rel="external">window</a>는 Transformation Operator중 개념 이해하기가 가장 난해했다. 결과적으로 이야기 하면… Outer Observable이 발생할 때마다 Inner Observable을 각각의 Observable(window)로 쪼개서 배출한다. 이는 마치 자바스크립트의 <code>split</code> method와 비슷하다.<br><code>window</code>로 시작하는 Operator들이 몇가지 있는데 기본 동작 원칙은 같다. 한 Observable의 스트림을 기반으로 새로운 Observable들을 반환한다. 그리고 이 Operator의 인자로 언제 새로운 Observable을 만들고, 언제 없앨지를 정한다.</p>
<p>아래 소스에서는 2초마다 스트림이 발생하는 Observable(interval)이 있고, 각 스트림이 실행될 때 마다 클릭 이벤트를 바라보는 Observable(clicks)이 생성된다. 이 clicks는 스트림이 끝날 때 같이 종료된다. 또한 clicks은 한 스트림 안에서 2번까지의 클릭만 스트림을 발생시킨다. 다소 복잡할 수 있지만 아래의 소스를 이해한다면 window의 개념을 어느정도 잡을 수 있을 것이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> clicks = Rx.Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'click'</span>);</div><div class="line"><span class="keyword">const</span> interval = Rx.Observable.interval(<span class="number">2000</span>);</div><div class="line"><span class="keyword">const</span> result = clicks.window(interval) <span class="comment">//2초마다 클릭 이벤트를 바라보는 Observable(윈도우)틀 배출한다.</span></div><div class="line">  .map(<span class="function"><span class="params">win</span> =&gt;</span> win.take(<span class="number">2</span>)) <span class="comment">// 각 윈도우는 2개의 스트림만을 받는다.</span></div><div class="line">result.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'out'</span>);<span class="comment">//2초마다 클릭이벤트 Observable 발생</span></div><div class="line">  x.subscribe(</div><div class="line">    <span class="function"><span class="params">y</span> =&gt;</span> <span class="built_in">console</span>.log(y),<span class="comment">//클릭할때 스트림 발생</span></div><div class="line">    err =&gt; <span class="built_in">console</span>.log(err),</div><div class="line">    () =&gt; <span class="built_in">console</span>.log(<span class="string">'finish'</span>)<span class="comment">//2번의 클릭 스트림 발생했거나 2초가 지났으면 complete매소드 실행</span></div><div class="line">  )&#125;</div><div class="line">);</div></pre></td></tr></table></figure></p>
<h4 id="windowCount"><a href="#windowCount" class="headerlink" title="windowCount"></a>windowCount</h4><p><a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-windowCount" target="_blank" rel="external">windowCount</a>는 인자로 숫자를 받는다. 이 숫자 개수만큼 Outer Observable의 스트림을 묶어서 하나의 Observable로 분출한다. 위에서 살펴본 인자의 숫자만큼 대기한다는 측면에서 <code>bufferCount</code>과 매칭된다.</p>
<p>아래 소스는 클릭 스트림이 3번 쌓일때마다 클릭 Observable을 complete하고 새로운 클릭 스트림을 만든다. (순수함수라는 측면에서 전역변수를 쓰는건 안좋은 방법이지만 이해를 돕기위해 cnt라는 전역변수를 만들었다.)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> cnt = <span class="number">0</span>;</div><div class="line"><span class="keyword">const</span> clicks = Rx.Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'click'</span>);</div><div class="line"><span class="keyword">const</span> result = clicks.windowCount(<span class="number">3</span>)</div><div class="line">result.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'click Observable Start'</span>); <span class="comment">//클릭 Observable 생성</span></div><div class="line">  x.subscribe(</div><div class="line">    <span class="function"><span class="params">y</span> =&gt;</span> <span class="built_in">console</span>.log(++cnt),<span class="comment">//클릭할때마다 숫자 1씩 증가</span></div><div class="line">    e =&gt; e,</div><div class="line">    () =&gt; (cnt = <span class="number">0</span>, <span class="built_in">console</span>.log(<span class="string">'click Observable completed'</span>)) <span class="comment">//클릭 Observable 종료</span></div><div class="line">  ),</div><div class="line">  e =&gt; e,</div><div class="line">  () =&gt; (<span class="built_in">console</span>.log(<span class="string">'completed'</span>));</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h4 id="windowTime"><a href="#windowTime" class="headerlink" title="windowTime"></a>windowTime</h4><p><a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-windowTime" target="_blank" rel="external">windowTime</a>는 인자로 두개의 숫자를 받는다, 첫번째는 생성된 window가 지속될 시간이고, 두번째는 window의 생성 주기를 나타내는 시간이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> clicks = Rx.Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'click'</span>);</div><div class="line"><span class="keyword">const</span> result = clicks.windowTime(<span class="number">2000</span>, <span class="number">5000</span>) <span class="comment">//Observable이 2초후 종료됨. Observable생성 5초 후에 새로운 Observable이 시작.</span></div><div class="line">  .map(<span class="function"><span class="params">win</span> =&gt;</span> win.take(<span class="number">2</span>)) <span class="comment">// 각 윈도우는 2개의 스트림만을 받는다.</span></div><div class="line">result.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'start'</span>)</div><div class="line">  x.subscribe(</div><div class="line">    <span class="function"><span class="params">y</span> =&gt;</span> <span class="built_in">console</span>.log(y), <span class="comment">//클릭할때 스트림 발생</span></div><div class="line">    err =&gt; <span class="built_in">console</span>.log(err),</div><div class="line">    () =&gt; <span class="built_in">console</span>.log(<span class="string">'finish'</span>) <span class="comment">//2초가 지나거나 클릭 스트림이 2번 발생할경우 complete</span></div><div class="line">  )</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="windowToggle"><a href="#windowToggle" class="headerlink" title="windowToggle"></a>windowToggle</h4>
                    
                        
                    
                    
                        <p>
                            <a href="/2017/01/01/rxjs-trans-operator/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/12/31/rxjs-create-operator/">
                            RxJS Create Operator
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-12-31T16:34:43+09:00">
	
		    12월 31, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/RxJS/">RxJS</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p>Operators는 Observable에서 작동되는 method들이다. (<code>.map(...)</code>, <code>.filter(...)</code>, <code>.merge(...)</code> …) 이들은 실행되면 현재 Observable의 인스턴스를 바꾸지는 않는다. 다만 첫번째 Observable의 subscription 로직을 기반으로 새로운 Observable을 return한다. 따라서 이전의 Observable은 수정되거나 하지 않는다(immutability).<br>Operator는 필수적으로  Observable를 취하고, 새로운 Observable을 생성하는 순수함수이다.</p>
<p>우선 이번 페이지에서는  Observable을 생성하는 Operators를 살펴보려고 한다.</p>
<hr>
<h4 id="bindCallback"><a href="#bindCallback" class="headerlink" title="bindCallback"></a>bindCallback</h4><p>인자로는 3개를 받는데, <code>1.콜백이 포함된 함수</code>, <code>2.출력될 옵저버블에 전달할 값</code>, <code>3.스케줄러</code> 로 구성된다. 해당 함수의 마지막 인자를 콜백으로 실행시킨다.아래는 <code>getJSON</code>의 예제이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> getJSONAsObservable = Rx.Observable.bindCallback(jQuery.getJSON);</div><div class="line"><span class="keyword">const</span> result = getJSONAsObservable(<span class="string">'/my/url'</span>);</div><div class="line">result.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x), e =&gt; <span class="built_in">console</span>.error(e));</div></pre></td></tr></table></figure>
<h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><p>defer는 스트림의 실행을 미루는 method이다.  인자는 옵저버블이나 프라미스 객체를 리턴하는 함수를 받으며  observable을 생성한다. 따라서 defer가 어떤 observable을 리턴하느냐에 따라서 스트림이 결정된다.<br><em>public static defer(observableFactory: function(): Observable or Promise): Observable</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> clicksOrInterval = Rx.Observable.defer(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span>) &#123;</div><div class="line">    <span class="keyword">return</span> Rx.Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'click'</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> Rx.Observable.interval(<span class="number">1000</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">clicksOrInterval.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</div></pre></td></tr></table></figure>
<h4 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h4><p>empty는 빈 스트림을 반환한다. 일단 스트림을 만들고 동적으로 값을 생성하거나 할 때, 혹은 조건에 따라 동적으로 다른 스트림을 만들때 쓰일것으로 보인다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> result = Rx.Observable.empty().startWith(<span class="number">7</span>);</div><div class="line">result.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x)); <span class="comment">//7</span></div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> interval = Rx.Observable.interval(<span class="number">1000</span>);</div><div class="line"><span class="keyword">const</span> result = interval.mergeMap(<span class="function"><span class="params">x</span> =&gt;</span></div><div class="line">  x % <span class="number">2</span> === <span class="number">1</span> ? Rx.Observable.of(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>) : Rx.Observable.empty()</div><div class="line">);<span class="comment">//1초에 한번씩 일어나는 스트림에 조건(x % 2 === 1)에따른 스트림을 합친다(mergeMap).</span></div><div class="line">result.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</div></pre></td></tr></table></figure>
<h4 id="from"><a href="#from" class="headerlink" title="from"></a>from</h4><p>가장많이 쓰이는 생성 operator중 하나일것이다. 인자로는 Observable로 변환시킬 수 있는 모든 값을 받을 수 있다. 구독가능한 객체, Promise 객체, 배열, 유사배열, 이터러블 인터페이스를 따르는 값들이 된다. iterable interface는 ES6에 추가된 문법으로 이에 해당되는 것으로는 배열, 문자열, gernerator 함수로 부터 도출된 interator 객체, Map 객체, Set 객체 등이다.</p>
<p>가장 기본적인 from method형태. 배열을 인자로 받아 스트림을 생성한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> input = Rx.Observable.from([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</div><div class="line">input.subscribe(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(i)</div><div class="line">&#125;,<span class="string">''</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'completed'</span>)</div><div class="line">&#125;); <span class="comment">//1, 2, 3, 4, 'completed'</span></div></pre></td></tr></table></figure></p>
<p>from은 generator 함수로부터 생성된 interator객체도 인자로 받을 수 있다. generator에 대한 자세한 설명은 <a href="http://hacks.mozilla.or.kr/2015/08/es6-in-depth-generators/" target="_blank" rel="external">여기</a>를 참조.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generateDoubles</span>(<span class="params">seed</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> i = seed;</div><div class="line">  <span class="keyword">while</span> (i&lt;<span class="number">100</span>) &#123;</div><div class="line">    <span class="keyword">yield</span> i;</div><div class="line">    i = <span class="number">2</span> * i; <span class="comment">// double it</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> iterator = generateDoubles(<span class="number">3</span>);</div><div class="line"><span class="keyword">var</span> result = Rx.Observable.from(iterator);</div><div class="line">result.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x),</div><div class="line">  e =&gt; <span class="built_in">console</span>.error(e),</div><div class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'finished'</span>));</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>앞서 야기 한대로, from operator는 promise도 받는다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> data = fetch(<span class="string">'https://api.zigbang.com/v1/search/subway?q='</span>).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</div><div class="line">  <span class="keyword">return</span> data.json();</div><div class="line">&#125;);</div><div class="line"><span class="keyword">var</span> ob = Rx.Observable.from(data).flatMap(<span class="function"><span class="params">x</span>=&gt;</span>x);</div><div class="line">ob.subscribe(<span class="function"><span class="params">e</span>=&gt;</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(e.name); <span class="comment">//지하철역들...</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h4 id="fromEvent"><a href="#fromEvent" class="headerlink" title="fromEvent"></a>fromEvent</h4><p>Creates an Observable that emits events of a specific type coming from the given event target.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> clicks = Rx.Observable.fromEvent(<span class="built_in">document</span>, <span class="string">'click'</span>);</div><div class="line">clicks.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</div></pre></td></tr></table></figure></p>
<h4 id="fromEventPattern"><a href="#fromEventPattern" class="headerlink" title="fromEventPattern"></a>fromEventPattern</h4><p>Creates an Observable from an API based on addHandler/removeHandler functions.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addClickHandler</span>(<span class="params">handler</span>) </span>&#123;</div><div class="line">  <span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, handler);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeClickHandler</span>(<span class="params">handler</span>) </span>&#123;</div><div class="line">  <span class="built_in">document</span>.removeEventListener(<span class="string">'click'</span>, handler);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> clicks = Rx.Observable.fromEventPattern(addClickHandler,removeClickHandler);</div><div class="line">clicks.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</div></pre></td></tr></table></figure></p>
<h4 id="fromPromise"><a href="#fromPromise" class="headerlink" title="fromPromise"></a>fromPromise</h4><p>Promise를 Observable로 컨버팅한다. 만일 Promise가 resolve된다면 resolved value를 Observable로 넘긴다. 만일 Promise가 reject되면 Observable error를 넘긴다.</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/12/31/rxjs-create-operator/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/12/29/rxjs-purity/">
                            RxJS - Purity(순수성)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-12-29T00:00:00+09:00">
	
		    12월 29, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/RxJS/">RxJS</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h3 id="RxJS-Purity-순수성"><a href="#RxJS-Purity-순수성" class="headerlink" title="RxJS - Purity(순수성)"></a>RxJS - Purity(순수성)</h3><h4 id="Purity-순수성"><a href="#Purity-순수성" class="headerlink" title="Purity(순수성)"></a>Purity(순수성)</h4><p>RxJS는 순수함수로 이루어져있다는 뜻이다. 순수함수란 함수형 프로그래밍에서 쓰이는 단어이다. 사람들마다 그리고 언어들마다 순수함수에 대한 정의가 약간씩 다른 것 같긴 하지만.. 내가 아는 순수함수의 정의는 아래와 같다.</p>
<ul>
<li>같은 입력에 항상 같은 출력을 반환한다.</li>
<li>사이드 이펙트가 없다.</li>
<li>외부 상태와 무관하다.</li>
</ul>
<p>순수함수는 해당 함수보다 상위의 스콥에서 정의된 함수를 참조하지 않는다. 오로지 인자로 인해 제어된다. 같은 값을 출력하기때문에 랜덤(Math.random)이나 날짜(new Date)등을 사용하지 않는다. 따라서 오류가 발생할 가능성이 적다. RxJS는 이 부분을 장점으로 내세우고 있다.</p>
<p>아래 예제를 보면…<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> observable = Rx.Observable.from([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</div><div class="line"> .map(<span class="function"><span class="params">x</span> =&gt;</span> x*x)</div><div class="line"> .scan(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a+b, <span class="number">0</span>);</div><div class="line">observable.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x)); <span class="comment">//1, 5, 14, 50</span></div></pre></td></tr></table></figure></p>
<p>RxJS는 위처럼 체이닝으로 method들을 이어 나간다. 그리고 다음 method들의 함수 내부는 이전함수로 부터 return받은 인자로만 이루어 진다. 물론 global 영역에 변수를 지정하고 가져오는게 불가능 한건 아니지만, 되도록 순수하게 함수를 사용하는 것을 권장한다. 아무래도 순수함수가 가진 안정성과 속도의 장점을 가져가려는 것이 아닐까 생각한다.</p>
<h4 id="Flow-흐름"><a href="#Flow-흐름" class="headerlink" title="Flow(흐름)"></a>Flow(흐름)</h4><p>RxJS에는 관찰자를 통해 이벤트가 흐르는 방식을 제어하는 데 도움이되는 다양한 연산자(operator)가 있다. 위에서 등장한 map, scan 등이 그것이다. 하나 하나의 흐름을 operator들로 전달하는 방식으로 동작하는 것이다.</p>
<h4 id="Values-값"><a href="#Values-값" class="headerlink" title="Values(값)"></a>Values(값)</h4><p>RxJS의 흐름이 진행되는 과정에서 인자로 값들을 넘긴다. RxJS는 operator들을 통해 이 값들을 원하는 값을 도출한다.</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/12/29/rxjs-purity/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/12/23/rxjs/">
                            Reactive extension JS (RxJS) 시작!
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-12-23T12:34:00+09:00">
	
		    12월 23, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/RxJS/">RxJS</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="Reactive-extension-JS-RxJS"><a href="#Reactive-extension-JS-RxJS" class="headerlink" title="Reactive extension JS (RxJS)"></a>Reactive extension JS (RxJS)</h2><p>RxJS에 대해 학습한 내용을 정리해서 포스팅 해보고자 한다.</p>
<p>여기 글을 RxJS공식 사이트(<a href="http://reactivex.io/rxjs)를" target="_blank" rel="external">http://reactivex.io/rxjs)를</a> 근간으로 하고 있다.</p>
<p>RxJS 공식사이트에서는 RxJS를 한문장으로 정의하고 있다..</p>
<blockquote>
<p>Think of RxJS as Lodash for events.</p>
</blockquote>
<p>이벤트의 로다시 같다는 것이다.. 로다시가 무엇인가. 함수형 프로그래밍을 위한 라이브러리가 아닌가…? 대신 로다시가 절차지향적 방식이라면 RxJS는 이벤트 기반의 비동시 방식이라는 차이가 있는 것으로 보인다.</p>
<p>RxJS는 다음과 같은 키워드로 정의되고 있다.</p>
<ul>
<li>Observable: 미래의 값(value)나 이벤트의 호출 가능한 수집의 개념을 나타냄.</li>
<li>Observer: Observable에 의해 전달 된 값을 처리하는 콜백 콜렉션.</li>
<li>Subscription: Observable의 실행을 나타냄. 주로 실행 취소에 유용함.</li>
<li>Operators: map, filter, concat, flatMap 등과 같은 method를 사용하여 컬렉션을 다루는 함수 프로그래밍 스타일을 가능하게하는 순수(pure) 함수.</li>
<li>Subject: EventEmitter와 동일하며 여러 Observers에 값 또는 이벤트를 멀티 캐스팅함.</li>
<li>Schedulers: 동시 처리를 제어하는 중앙 집중식 디스패처로서 계산이 언제 발생하는지 조정할 수 있다. setTimeout or requestAnimationFrame or others.</li>
</ul>
<p>RxJS가 힘든 이유는 2가지 인것 같다.</p>
<ul>
<li>이벤트 기반의 비동기 처리 프로그래밍 방식이 개념적으로 익숙하지 않다.</li>
<li>익혀야할 용어나 method들이 많다.<br>앞으로 하나씩 하나씩 익혀보자.</li>
</ul>
<p>초반 개념을 잡는데 네이버 김훈민 님의 강의가 많은 도움이 됐다. 아래는 관련 블로그나 강의 영상의 링크다. 내용이 많이 겹치지만 일부 다른 부분들도 있어서 되도록 알고있는 모든 링크를 첨부한다.</p>
<p>블로그: <a href="http://huns.me/development/2051" target="_blank" rel="external">http://huns.me/development/2051</a><br>나프타 컨퍼런스 영상: <a href="https://www.youtube.com/watch?v=3FKlYO4okts" target="_blank" rel="external">https://www.youtube.com/watch?v=3FKlYO4okts</a><br>웹 프론트엔드 개발자의 얕고 넓은 Rx 이야기: <a href="http://www.slideshare.net/jeokrang/rx-70197043" target="_blank" rel="external">http://www.slideshare.net/jeokrang/rx-70197043</a></p>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/12/23/rxjs/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">page 1 of 1</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2017 Owen. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <h4 id="about-card-name">Owen</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-close"></i></span>
            <a href="https://algolia.com" target="_blank" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    autofocus="autofocus"/>
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">no post found</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://owenjeon.github.io/2016/07/12/prototype/">
                            <h3 class="media-heading">객체 및 프로토타입</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 7월 12일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://owenjeon.github.io/2016/07/12/fill-image-css/">
                            <h3 class="media-heading">프레임에 이미지 꽉 채우기 Part2(css)</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 7월 12일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://owenjeon.github.io/2016/07/12/fill-image-javascript/">
                            <h3 class="media-heading">프레임에 이미지 꽉 채우기 Part2(Javascript)</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 7월 12일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://owenjeon.github.io/2016/08/10/prototype/">
                            <h3 class="media-heading">자바스크립트 프로토 타입의 프로퍼티 할당</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 8월 10일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://owenjeon.github.io/2016/08/12/array-object/">
                            <h3 class="media-heading">객체와 배열 구분하기</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 8월 12일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://owenjeon.github.io/2016/08/18/develop-patten/">
                            <h3 class="media-heading">다른 퍼블리셔들의 사용패턴 설문조사</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 8월 18일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://owenjeon.github.io/2016/08/21/valueof-tostring/">
                            <h3 class="media-heading">Javascript의 valueOf, toString</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 8월 21일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://owenjeon.github.io/2016/08/22/javascript-jsonp/">
                            <h3 class="media-heading">JSONP에 관하여...</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 8월 22일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://owenjeon.github.io/2016/08/28/javascript-reduce/">
                            <h3 class="media-heading">ECMA5 javascript method : reduce</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 8월 28일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://owenjeon.github.io/2016/09/01/javascript-map/">
                            <h3 class="media-heading">ECMA5 javascript method : map</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016년 9월 1일
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="no post found"
                data-message-one="1 post found"
                data-message-other="{n} posts found">
                22 posts found
            </p>
        </div>
    </div>
</div>
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-keald3mnqximb0hm6mvdqo5sxhnyqoujkpxdeikbcx5yiukrhiboqm2jxh0x.min.js"></script>
<!--SCRIPTS END-->



    </body>
</html>
